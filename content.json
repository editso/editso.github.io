{"pages":[{"title":"About","date":"2023-06-29T10:21:29.659Z","path":"about/index.html","text":""},{"title":"Categories","date":"2023-06-29T10:21:29.659Z","path":"categories/index.html","text":"aaa"},{"title":"Tags","date":"2023-06-29T10:21:29.663Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2023-06-29T10:21:29.659Z","path":"categories/aa/index.html","text":"hEllo"},{"title":"别看啦, 没有拿的出手的项目","date":"2023-06-29T10:21:29.663Z","path":"wiki/empty/index.html","text":""}],"posts":[{"title":"Arm64汇编记录","date":"2023-06-29T10:37:00.000Z","path":"wiki/arm64/","text":"相关指令记录ARDP ADRP &lt;reg&gt; &lt;imm&gt; 从PC相对地址到4KB页添加一个直接值 将当前pc地址低12位置零, 并加上立即数左移12位后的值 例子: 12345678PC = 0xe7b27341c7b0reg = x16imm = 866; adrp x16, 866x16 = (0xe7b27341c7b0 &amp; (~0xFFF)) + (866 &lt;&lt; 12) = 0xe7b27377e000 CBZ CBZ &lt;reg&gt; &lt;imm&gt; 将寄存器的值与0比较, 如过相等则跳转到相对pc +/-1MB的位置 例子: 1234567reg = x0imm = 0xe7b273333c84; cbz x0, 0xe7b273333c84if (x0 == 0 ) goto 0xe7b273333c84...continue XZR用于64位(8字节)置零操做 例子: 1234; 将x20寄存器置零; mov x20, xzrx20 = 0 LDP LDP &lt;reg1&gt;, &lt;reg2&gt;, [reg3], &lt;imm&gt; 将reg3地址里面的值加载到reg1和reg2 然后更新reg3的值, reg3 += imm 例子: 123456789sp = uint64[]&#123; 2, 3 &#125;; ldp, x0, x1, [sp], #0x10x0 = *sp = 2x1 = *(sp + 8) = 3sp = sp + 16 STP STP &lt;reg1&gt;, &lt;reg2&gt;, [reg3, imm]! 将reg1,reg2中的值存入 reg3 + imm的地址里面, 并更新 reg3的值 reg3 += imm 例子: 12345678910x1 = 1x2 = 2; stp x1, x2, [sp, #-10]!*(sp - 16) = x1 = 1*(sp - 16 - 8) = x2 = 2sp = sp - 16","tags":[{"name":"ASM","slug":"ASM","permalink":"http://editso.github.io/tags/ASM/"},{"name":"Arm","slug":"Arm","permalink":"http://editso.github.io/tags/Arm/"},{"name":"Arm64","slug":"Arm64","permalink":"http://editso.github.io/tags/Arm64/"}],"categories":[{"name":"汇编学习","slug":"汇编学习","permalink":"http://editso.github.io/categories/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"}]},{"title":"线程局部存储(TLS)","date":"2022-02-12T20:44:14.000Z","path":"wiki/windows-thread-local/","text":"什么是线程局部存储?线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。这种对象的链接性（linkage）可以是静态的也可是外部的。在Windows上TLS的存储结构为: 静态TLS静态TLS需要使用 __declspace(thread) 变量 进行标识, 当编译器进行打包时会将它存储到特定的节中(.tls)它将会变成一个tls模板, 在程序进行线程创建时将会开辟一个足够大的空间将tls模板数据复制进去(tls副本), 所以每个线程访问与修改它时互不干扰. PE加壳带静态TLS如何修复?这个问题我也是折腾了很久, 在网上找了很久的资料基本上都是讲的TLS Callback,反调试相关的, 然后看了&lt;&lt;Windows PE权威指南&gt;&gt;虽然有说静态TL是如何存储的,但是没有例子,只是说了下 不过已经知道TLS是存储在哪儿的 那不就好办了? 书上说的是“当创建线程时，加载器通过将线程环境块（TEB）的地址放入FS寄存器来传递线程的TLS数组地址。距TEB开头0x2C的位置处的字段ThreadLocalStoragePointer指向TLS数组” 书上这里说的是32位的, 64位的可以自己去查 TEB相关字段偏移 也就是说只要我将 TLS模板中的数据先写到一块内存中, 然后将数据首地址写入这个数组中就好了?跟着书上说的我去试了下, 发现有大坑!!!, 然后我仔细想了想了TEB在每个线程都是不一样的, 所以我加进去的只是TLS副本也就是说我只给我当前获取到TEB的那个线程加进去了, 其他的还是没有然后这样会导致我的程序在开新线程的时候获取不到TLS数据… 离谱吧, 所以在程序中不开线程访问是莫问题滴… 但是对于简单的程序还好, 要是遇到网络相关操作的一个线程?? 所以这个算只是解决了半个问题??.. 现在大概是知道问题所在, 我修改的只是TLS副本, 所以我只需要修改加载器的TLS模板数据就可以了? (也就是说将加载器TLS数据模板替换为我主程序的模板数据). 但是我怎么知道加壳程序TLS模板存储位置呢.. 带着这个问题又去查资料, 果然在Github找到一个外国佬写的pe_loader而且它支持静态TLS的加载, 所以我去看了他的代码 tls_support.cpp 他获取这个模板数据首地址是硬搜的, 先拿到TLS表然后去内存匹配芜湖~ 这不就是我想要的? 好像他的代码挺复杂的, 不过已经知道办法了只需要撸代码了 代码代码就不贴了, 我写的代码垃圾.. 就截个图吧 参考资料 线程局部存储 线程局部存储结构图 找首地址","tags":[],"categories":[{"name":"Windows","slug":"Windows","permalink":"http://editso.github.io/categories/Windows/"},{"name":"PE","slug":"Windows/PE","permalink":"http://editso.github.io/categories/Windows/PE/"}]},{"title":"PE头文件学习笔记","date":"2021-11-05T13:01:22.000Z","path":"wiki/pe/","text":"可移植可执行 是一种用于可执行文件、目标文件和动态链接库的文件格式，主要使用在32位和64位的Windows操作系统上。可移植的是指该文件格式的通用性，可用于许多种不同的操作系统和体系结构中。PE文件格式封装了Windows操作系统加载可执行程序代码时所必需的一些信息。这些信息包括动态链接库、API导入和导出表、资源管理数据和线程局部存储数据。在Windows NT操作系统中，PE文件格式主要用于EXE文件、DLL文件、.sys（驱动程序）和其他文件类型。可扩展固件接口（EFI）技术规范书中说明PE格式是EFI环境中的标准可执行文件格式。开头为DOS头部。 PE格式是由Unix中的COFF格式修改而来的。在Windows开发环境中，PE格式也称为PE/COFF格式。 DOS头 winnt.h结构体信息12345678910111213141516171819202122typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // * Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // * File address of new exe header&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 重要字段说明 e_magic: 4D5A 该字段标识是否是一个PE文件以 e_lfanew: – 指向 NT头(IMAGE_NT_HEADER) 起始地址 NT头NT在64和32结构没有发生变法, 只是字段类型长度有变 结构体信息x8612345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; x6412345typedef struct _IMAGE_NT_HEADERS64 &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader;&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; 重要字段说明 Signature: 5045 4字节PE标识 文件头结构体信息123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; // IMAGE_FILE_MACHINE_I386(0x014c) , IMAGE_FILE_MACHINE_IA64(0x0200), IMAGE_FILE_MACHINE_AMD64(0x8664) WORD NumberOfSections; // * DWORD TimeDateStamp; // - DWORD PointerToSymbolTable; // - DWORD NumberOfSymbols; // - WORD SizeOfOptionalHeader; // * WORD Characteristics; // *&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 重要字段说明 NumberOfSections 节数量 SizeOfOptionalHeader 可选PE头的大小 Characteristics 属性信息 可选PE头结构体信息x86123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; x641234567891011121314151617181920212223242526272829303132typedef struct _IMAGE_OPTIONAL_HEADER64 &#123; WORD Magic; // * BYTE MajorLinkerVersion; // - BYTE MinorLinkerVersion; // - DWORD SizeOfCode; // - DWORD SizeOfInitializedData; // - DWORD SizeOfUninitializedData; // - DWORD AddressOfEntryPoint; // * DWORD BaseOfCode; // - ULONGLONG ImageBase; // * DWORD SectionAlignment; // * DWORD FileAlignment; // * WORD MajorOperatingSystemVersion; // - WORD MinorOperatingSystemVersion; // - WORD MajorImageVersion; // - WORD MinorImageVersion; // - WORD MajorSubsystemVersion; // - WORD MinorSubsystemVersion; // - DWORD Win32VersionValue; // - DWORD SizeOfImage; // * DWORD SizeOfHeaders; // * DWORD CheckSum; // - WORD Subsystem; // - WORD DllCharacteristics; // - ULONGLONG SizeOfStackReserve; // - ULONGLONG SizeOfStackCommit; // - ULONGLONG SizeOfHeapReserve; // - ULONGLONG SizeOfHeapCommit; // - DWORD LoaderFlags; // - DWORD NumberOfRvaAndSizes; // - IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; 重要字段说明 Magic: IMAGE_NT_OPTIONAL_HDR32_MAGIC: 0x10b 32位可执行文件 IMAGE_NT_OPTIONAL_HDR64_MAGIC: 0x20b 64位可执行文件 IMAGE_ROM_OPTIONAL_HDR_MAGIC: 0x107 ROM文件 AddressOfEntryPoint: 存储入口函数偏移, 该值只是一个偏移, 真实地址需要加上 ImageBase ImageBase: 在内存中加载的首地址, 该值是64K字节的倍数 DLL 的默认值为 0x10000000。应用程序的默认值为0x00400000，但0x00010000的 Windows CE 除外 SectionAlignment: 在内存中加载后节表应该按多少字节对齐 FileAlignment: 在文件中应该按多少字节对齐, 默认按512K对齐 SizeOfImage: 加载到内存中的总大小 SizeOfHeaders: PE头总大小, 包括节表 节表节表中定义了相关数据开始与结束信息 (如: 代码段, 数据段, …), 它很重要,但节表中的值都是RAV 也就是拉伸后的偏移地址 结构体信息123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // * union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; // * DWORD VirtualAddress; // * DWORD SizeOfRawData; // * DWORD PointerToRawData; // * DWORD PointerToRelocations; // - DWORD PointerToLinenumbers; // - WORD NumberOfRelocations; // - WORD NumberOfLinenumbers; // - DWORD Characteristics; // *&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 重要字段说明 Name: 节表名称, 注意它不会以0结尾, 所以在获取节表名称时需要注意 Misc: 它在内存中加载后的大小 VirtualAddress: 内存中的偏移(RVA) SizeOfRawData: 节区数据大小, Misc 中的数据可能比它大 PointerToRawData: 文件偏移地址(FOV) 目录表目录表有16个, 分别为: IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: 7 Architecture-specific data IMAGE_DIRECTORY_ENTRY_BASERELOC: 5 Base relocation table IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: 11 Bound import directory IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: 14 COM descriptor table IMAGE_DIRECTORY_ENTRY_DEBUG: 6 Debug directory IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: 13 Delay import table IMAGE_DIRECTORY_ENTRY_EXCEPTION: 3 Exception directory IMAGE_DIRECTORY_ENTRY_EXPORT: 0 Export directory IMAGE_DIRECTORY_ENTRY_GLOBALPTR: 8 The relative virtual address of global pointer IMAGE_DIRECTORY_ENTRY_IAT: 12Import address table IMAGE_DIRECTORY_ENTRY_IMPORT: 1Import directory IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: 10Load configuration directory IMAGE_DIRECTORY_ENTRY_RESOURCE: 2Resource directory IMAGE_DIRECTORY_ENTRY_SECURITY: 4Security directory IMAGE_DIRECTORY_ENTRY_TLS: 9Thread local storage directory 结构体信息1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; // * DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 重要字段信息说明 VirtualAddress: 指向各表偏移(RVA) 目标表相关结构体这里只列出 导出表, 导入表, 重定位表 导出表导出表比较复杂, 需要理解导出方式与查找函数首地址 结构体信息导出表12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 重要字段说明 Name: 导出文件名称偏移地址 (RVA) Base: 需要开始 NumberOfFunctions: 导出函数数量 NumberOfNames: 以名称导出的函数数量 AddressOfFunctions: 导出的函数存放首地址偏移 (RVA) AddressOfNames: 以名称导出的函数存放首地址偏移(RVA) AddressOfNameOrdinals: 以名称导出的函数指向的序号地址偏移 (RVA) 打印32位导出表信息列子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;Windows.h&gt;#include &lt;winnt.h&gt;#include &lt;stdio.h&gt;DWORD RvaToFov(PIMAGE_SECTION_HEADER sec, DWORD secCount, DWORD rva) &#123; for (int i = 0; i &lt; secCount; i++) &#123; if (sec-&gt;VirtualAddress &lt;= rva &amp;&amp; sec-&gt;VirtualAddress + sec-&gt;SizeOfRawData &gt;= rva) &#123; return rva - sec-&gt;VirtualAddress + sec-&gt;PointerToRawData; &#125; sec++; &#125; return 0;&#125;void printExportTable(const char* dllName) &#123; LPBYTE lpBuffer = NULL; HANDLE hFile = NULL; DWORD fileSize = 0, readSize = 0, secCount = 0; LPDWORD lpExportFunctions = NULL, lpExportFunctionNames = NULL; LPWORD lpExportFunctionOrdinals = NULL; PIMAGE_DOS_HEADER lpDosHeader = NULL; PIMAGE_NT_HEADERS32 lpNtHeader = NULL; PIMAGE_SECTION_HEADER lpFirstSection = NULL; PIMAGE_EXPORT_DIRECTORY lpExport = NULL; hFile = CreateFileA(dllName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (!hFile) &#123; printf(&quot;读取%s失败\\n&quot;, dllName); goto exit; &#125; fileSize = GetFileSize(hFile, NULL); lpBuffer = (LPBYTE)VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE); if (!lpBuffer) &#123; printf(&quot;分配内存失败 %d\\n&quot;, fileSize); goto exit; &#125; if (!ReadFile(hFile, lpBuffer, fileSize, &amp;readSize, NULL)) &#123; goto exit; &#125; lpDosHeader = (PIMAGE_DOS_HEADER)lpBuffer; if (lpDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123; printf(&quot;不是一个有效的PE文件\\n&quot;); goto exit; &#125; lpNtHeader = (PIMAGE_NT_HEADERS32)(lpBuffer + lpDosHeader-&gt;e_lfanew); if (lpNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123; printf(&quot;不是一个有效的PE文件\\n&quot;); goto exit; &#125; if (lpNtHeader-&gt;OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123; printf(&quot;不是一个32位PE文件\\n&quot;); goto exit; &#125; secCount = lpNtHeader-&gt;FileHeader.NumberOfSections; lpFirstSection = (PIMAGE_SECTION_HEADER)((LPBYTE)&amp;lpNtHeader-&gt;OptionalHeader + lpNtHeader-&gt;FileHeader.SizeOfOptionalHeader); lpExport = lpBuffer + RvaToFov( lpFirstSection, secCount, lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress ); // 导出函数 lpExportFunctions = (LPDWORD)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpExport-&gt;AddressOfFunctions )); // 导出函数名称 lpExportFunctionNames = (LPDWORD)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpExport-&gt;AddressOfNames )); // 导出序号 lpExportFunctionOrdinals = (LPWORD)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpExport-&gt;AddressOfNameOrdinals )); printf(&quot;导出文件名称: %s\\n&quot;, lpBuffer + RvaToFov(lpFirstSection, secCount, lpExport-&gt;Name)); printf(&quot;导出函数总数: 0x%x\\n&quot;, lpExport-&gt;NumberOfFunctions); printf(&quot;导出函数名称总数: 0x%x\\n&quot;, lpExport-&gt;NumberOfNames); for (int i = 0, j = 0; i &lt; lpExport-&gt;NumberOfFunctions; i++, j = 0) &#123; for (; j &lt; lpExport-&gt;NumberOfNames; j++) &#123; if (i == lpExportFunctionOrdinals[j]) &#123; break; &#125; &#125; if (j &lt; lpExport-&gt;NumberOfNames) &#123; printf(&quot;\\n以函数名称导出: \\n\\t名称: %s\\n\\t地址: 0x%x\\n\\t序号: 0x%x\\n&quot;, lpBuffer + RvaToFov( lpFirstSection, secCount, lpExportFunctionNames[j] ), lpExportFunctions[i], lpExportFunctionOrdinals[j] + lpExport-&gt;Base ); &#125;else &#123; printf(&quot;\\n以序号导出: \\n\\t地址: 0x%x\\n\\t序号: 0x%x\\n&quot;, lpExportFunctions[i], i + lpExport-&gt;Base); &#125; &#125;exit: if (hFile) &#123; CloseHandle(hFile); &#125; if (lpBuffer) &#123; VirtualFree(lpBuffer, 0, MEM_RELEASE); &#125;&#125; 导入表导入表也是比较复杂的, 需要理解导入方式 相关结构体信息导入表123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 名称表1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; CHAR Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 导入名称表与导入地址表12345678typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32; 重要字段说明 导入表 DUMMYUNIONNAME: 指向导入名称表的偏移(RVA) Name: 导入动态库的名称 FirstThunk: 指向导入地址表的偏移(RVA), 导入地址表在文件中是和导入名称表一样的, 但加载到内存后是不一样的 导入名称表与导入地址表 u1: 指向的是函数名称的偏移或者序号, 如果是函数明显那么最高位为0否则为序号 序号 = ul.Ordinal &amp; ~(0b1 &lt;&lt; 31) 名称表 Name 函数名称 打印32位导入表列子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;Windows.h&gt;#include &lt;winnt.h&gt;#include &lt;stdio.h&gt;DWORD RvaToFov(PIMAGE_SECTION_HEADER sec, DWORD secCount, DWORD rva) &#123; for (int i = 0; i &lt; secCount; i++) &#123; if (sec-&gt;VirtualAddress &lt;= rva &amp;&amp; sec-&gt;VirtualAddress + sec-&gt;SizeOfRawData &gt;= rva) &#123; return rva - sec-&gt;VirtualAddress + sec-&gt;PointerToRawData; &#125; sec++; &#125; return 0;&#125;void printImportTable(const char* peFileName) &#123; DWORD fileSize = 0, readSize = 0, secCount = 0; LPBYTE lpBuffer = NULL; HANDLE hFile = NULL; PIMAGE_DOS_HEADER lpDosHeader = NULL; // dos头 PIMAGE_NT_HEADERS32 lpNtHeader = NULL; // nt头 PIMAGE_SECTION_HEADER lpFirstSection = NULL; // 节表 PIMAGE_THUNK_DATA32 lpIntHeader = NULL, // 导入名称表 lpIatHeader = NULL; // 导入地址表 PIMAGE_IMPORT_BY_NAME lpImportName = NULL; PIMAGE_IMPORT_DESCRIPTOR lpImport = NULL; hFile = CreateFileA(peFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (!hFile) &#123; printf(&quot;读取%s失败\\n&quot;, peFileName); goto exit; &#125; fileSize = GetFileSize(hFile, NULL); lpBuffer = (LPBYTE)VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE); if (!lpBuffer) &#123; printf(&quot;分配内存失败 %d\\n&quot;, fileSize); goto exit; &#125; if (!ReadFile(hFile, lpBuffer, fileSize, &amp;readSize, NULL)) &#123; goto exit; &#125; lpDosHeader = (PIMAGE_DOS_HEADER)lpBuffer; if (lpDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123; printf(&quot;不是一个有效的PE文件\\n&quot;); goto exit; &#125; lpNtHeader = (PIMAGE_NT_HEADERS32)(lpBuffer + lpDosHeader-&gt;e_lfanew); if (lpNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123; printf(&quot;不是一个有效的PE文件\\n&quot;); goto exit; &#125; if (lpNtHeader-&gt;OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123; printf(&quot;不是一个32位PE文件\\n&quot;); goto exit; &#125; secCount = lpNtHeader-&gt;FileHeader.NumberOfSections; lpFirstSection = (PIMAGE_SECTION_HEADER)((LPBYTE)&amp;lpNtHeader-&gt;OptionalHeader + lpNtHeader-&gt;FileHeader.SizeOfOptionalHeader); lpImport = (PIMAGE_IMPORT_DESCRIPTOR)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) ); while (lpImport-&gt;Name != 0) &#123; printf(&quot;\\n 导入动态库名称: %s\\n&quot;, (lpBuffer + RvaToFov( lpFirstSection, secCount, lpImport-&gt;Name ))); lpIntHeader = (PIMAGE_THUNK_DATA32)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpImport-&gt;OriginalFirstThunk )); lpIatHeader = (PIMAGE_THUNK_DATA32)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpImport-&gt;FirstThunk )); while (lpIntHeader-&gt;u1.Function != 0) &#123; if (lpIatHeader-&gt;u1.Function &gt;&gt; 31 == 1) &#123; printf(&quot;\\t序号导入: 0x%x\\n&quot;, lpIatHeader-&gt;u1.Ordinal &amp; ~(0b1 &lt;&lt; 31)); &#125; else &#123; lpImportName = (PIMAGE_IMPORT_BY_NAME)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpIatHeader-&gt;u1.Function )); printf(&quot;\\t名称导入: %s\\n&quot;, lpImportName-&gt;Name); &#125; lpIntHeader++; lpIatHeader++; &#125; lpImport++; &#125; exit: if (hFile) &#123; CloseHandle(hFile); &#125; if (lpBuffer) &#123; VirtualFree(lpBuffer, 0, MEM_RELEASE); &#125; &#125; 重定位表结构体信息123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; DWORD SizeOfBlock;// WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; 重要字段说明 VirtualAddress: 偏移基址 SizeOfBlock: 当前表大小 打印32位重定位表列子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;Windows.h&gt;#include &lt;winnt.h&gt;#include &lt;stdio.h&gt;DWORD RvaToFov(PIMAGE_SECTION_HEADER sec, DWORD secCount, DWORD rva) &#123; for (int i = 0; i &lt; secCount; i++) &#123; if (sec-&gt;VirtualAddress &lt;= rva &amp;&amp; sec-&gt;VirtualAddress + sec-&gt;SizeOfRawData &gt;= rva) &#123; return rva - sec-&gt;VirtualAddress + sec-&gt;PointerToRawData; &#125; sec++; &#125; return 0;&#125;void printRelocTable(const char* peFileName) &#123; DWORD fileSize = 0, readSize = 0, secCount = 0; LPBYTE lpBuffer = NULL; HANDLE hFile = NULL; LPWORD lpRelocAddress = NULL; PIMAGE_DOS_HEADER lpDosHeader = NULL; // dos头 PIMAGE_NT_HEADERS32 lpNtHeader = NULL; // nt头 PIMAGE_SECTION_HEADER lpFirstSection = NULL; // 节表 PIMAGE_BASE_RELOCATION lpRelocHeader = NULL; hFile = CreateFileA(peFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (!hFile) &#123; printf(&quot;读取%s失败\\n&quot;, peFileName); goto exit; &#125; fileSize = GetFileSize(hFile, NULL); lpBuffer = (LPBYTE)VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE); if (!lpBuffer) &#123; printf(&quot;分配内存失败 %d\\n&quot;, fileSize); goto exit; &#125; if (!ReadFile(hFile, lpBuffer, fileSize, &amp;readSize, NULL)) &#123; goto exit; &#125; lpDosHeader = (PIMAGE_DOS_HEADER)lpBuffer; if (lpDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123; printf(&quot;不是一个有效的PE文件\\n&quot;); goto exit; &#125; lpNtHeader = (PIMAGE_NT_HEADERS32)(lpBuffer + lpDosHeader-&gt;e_lfanew); if (lpNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123; printf(&quot;不是一个有效的PE文件\\n&quot;); goto exit; &#125; if (lpNtHeader-&gt;OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123; printf(&quot;不是一个32位PE文件\\n&quot;); goto exit; &#125; secCount = lpNtHeader-&gt;FileHeader.NumberOfSections; lpFirstSection = (PIMAGE_SECTION_HEADER)((LPBYTE)&amp;lpNtHeader-&gt;OptionalHeader + lpNtHeader-&gt;FileHeader.SizeOfOptionalHeader); lpRelocHeader = (PIMAGE_BASE_RELOCATION)(lpBuffer + RvaToFov( lpFirstSection, secCount, lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress) ); while (lpRelocHeader-&gt;SizeOfBlock != 0) &#123; printf(&quot;\\n重定位修复: &quot;); printf(&quot;\\n\\t基址(RVA): 0x%x&quot;, lpRelocHeader-&gt;VirtualAddress); printf(&quot;\\n\\t块儿大小: 0x%x&quot;, lpRelocHeader-&gt;SizeOfBlock); printf(&quot;\\n\\t需要重定位数量: 0x%x&quot;, (lpRelocHeader-&gt;SizeOfBlock - 8) / 2); lpRelocAddress = (LPWORD)((LPBYTE)lpRelocHeader + 8); for (int i = 0; i &lt; (lpRelocHeader-&gt;SizeOfBlock - 8) / 2; i++) &#123; if (lpRelocAddress[i] &gt;&gt; 12 == 3) &#123; DWORD addrOffset = lpRelocAddress[i] &amp; 0xFFF; DWORD addrValue = *((DWORD *)(lpBuffer + RvaToFov( lpFirstSection, secCount, addrOffset + lpRelocHeader-&gt;VirtualAddress ))); printf(&quot;\\n\\t地址(RVA): 0x%x&quot;, addrOffset + lpRelocHeader-&gt;VirtualAddress); printf(&quot;\\n\\t当前值: 0x%x&quot;, addrValue); printf(&quot;\\n\\t偏移: 0x%x\\n&quot;, addrValue - lpNtHeader-&gt;OptionalHeader.ImageBase); &#125; &#125; lpRelocHeader = (PIMAGE_BASE_RELOCATION)((LPBYTE)lpRelocHeader + lpRelocHeader-&gt;SizeOfBlock); &#125;exit: if (hFile) &#123; CloseHandle(hFile); &#125; if (lpBuffer) &#123; VirtualFree(lpBuffer, 0, MEM_RELEASE); &#125;&#125;","tags":[{"name":"Windows","slug":"Windows","permalink":"http://editso.github.io/tags/Windows/"},{"name":"PE","slug":"PE","permalink":"http://editso.github.io/tags/PE/"}],"categories":[{"name":"Windows","slug":"Windows","permalink":"http://editso.github.io/categories/Windows/"},{"name":"PE","slug":"Windows/PE","permalink":"http://editso.github.io/categories/Windows/PE/"}]},{"title":"记一次C内存溢出问题","date":"2021-03-21T01:30:49.000Z","path":"wiki/c-01-log/","text":"记一次C内存溢出问题问题代码123456789101112#include &lt;stdio.h&gt;void func()&#123; char buff[1024 * 1024 * 10]; printf(&quot;hello func\\n&quot;);&#125;int main(int argc, char **argv)&#123; func(); return 0;&#125; 编译后运行直接段错误,查了半天硬是没查出问题, 后突然想到是不是栈空间满了,查了下百度果不其然在我的Linux下使用ulimit -s查出我的系统栈空间大小为8kb而我开辟了1MB的空间所以出现段错误 解决办法将 buff变量加上static关键字或缩小buff大小即可解决问题,还可以将buff作为全局变量","tags":[{"name":"C","slug":"C","permalink":"http://editso.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"GCC","slug":"GCC","permalink":"http://editso.github.io/tags/GCC/"}],"categories":[{"name":"问题记录","slug":"问题记录","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"C相关","slug":"问题记录/C相关","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/C%E7%9B%B8%E5%85%B3/"}]},{"title":"GRUB双系统找不到Windows问题","date":"2021-03-21T00:55:37.000Z","path":"wiki/grub-log/","text":"GRUB双系统找不到Windows问题问题截图 解决办法1.编辑: /etc/default/grub2.添加: GRUB_DISABLE_OS_PROBER=false3.执行: sudo update-grub 参考: 记一次 Grub 找回 Win10 启动项的过程","tags":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"GRUB","slug":"GRUB","permalink":"http://editso.github.io/tags/GRUB/"},{"name":"Manjaro","slug":"Manjaro","permalink":"http://editso.github.io/tags/Manjaro/"},{"name":"Windows","slug":"Windows","permalink":"http://editso.github.io/tags/Windows/"}],"categories":[{"name":"问题记录","slug":"问题记录","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Grub","slug":"问题记录/Grub","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Grub/"}]},{"title":"acm-士兵队列训练问题","date":"2020-11-08T15:44:38.000Z","path":"wiki/acm-01/","text":"士兵队列训练问题某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。 分析该题意思是,队列编号第一轮编号1~2叫到 2 的出列, 第二轮编号1~3叫到3的出列,反复循环直到剩余人数不超过3人 实现代码 c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void full(int num, int *soldier)&#123; for (int i = 0; i &lt; num; i++) &#123; soldier[i] = i+1; &#125;&#125;int* line_up(int num)&#123; int* soldier = malloc(sizeof(int) * num); //初始化士兵 full(num, soldier); /** * i: 当前士兵 * j: 报数 * s: 最高编号 */ for (int i = 0, j = 1, s = 2, m = num; m &gt;= 3; i++) &#123; if(i &gt; num &amp;&amp; s == 2)&#123; /** * 第一轮报数完成, 进行第二轮报数 */ s = 3; i = 0; j = 1; &#125;else if(i &gt; num &amp;&amp; s == 3)&#123; /** * 第二轮报数完成,重新开始到第一轮报数 */ s = 2, i = 0, j = 1; &#125; /** * 当前士兵已经出列, 继续报数 */ if(soldier[i] == -1) continue; if(j == s)&#123; /** * 出列 */ soldier[i] = -1; j = 1; m--; &#125;else&#123; j++; // 编号 &#125; &#125; return soldier;&#125;int out_soldier(int num)&#123; int *soldier = line_up(num); for (int i = 0; i &lt; num; i++) &#123; if(soldier[i] == -1) continue; printf(&quot;%d &quot;, soldier[i]); &#125; printf(&quot;\\n&quot;); free(soldier);&#125;int main()&#123; int row, col; scanf(&quot;%d&quot;, &amp;row); int array[row], i = 0; while (i &lt; row) &#123; scanf(&quot;%d&quot;, array + i++); &#125; i = 0; while (i &lt; row) &#123; out_soldier(array[i++]); &#125; return 0;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://editso.github.io/tags/Algorithm/"},{"name":"Acm","slug":"Acm","permalink":"http://editso.github.io/tags/Acm/"},{"name":"C","slug":"C","permalink":"http://editso.github.io/tags/C/"}],"categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://editso.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}]},{"title":"记录一次学习C++时编译失败出现(multiple definition of xxx first defined here collect2)","date":"2020-11-03T23:49:32.000Z","path":"wiki/c-log/","text":"记录一次学习C++时编译失败出现(multiple definition of xxx first defined here collect2)报错说我重复定义了这个重载函数, 网上查了半天,说是头文件没有写#ifndef &amp; #define可是我明明写了, 还是不起作用,又说使用关键字extern, 可是我就是要定义在头文件里面,后来看了c++的全局重载函数,发现都写了inline修饰,于是试了试结果成功了 解决办法使用inline修饰这个函数,使用它修饰需要考虑自己的代码是否符合inline inline相关在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。 个人理解我理解它其实就是和宏定义差不多,宏定义会在编译器编译时进行宏展开,而inline做的事情其实和它是差不多的,只不过inline会有一些使用限制.然后我这个错误在还未链接时是没有错误的,在链接是就出现了重复定义,使用inline就正好解决了我遇到的问题,因为它在编译时就会把这个函数转换为内联函数,所以在链接时就不会出现重复定义问题 参考资料 C++ 中的 inline 用法","tags":[{"name":"CPP","slug":"CPP","permalink":"http://editso.github.io/tags/CPP/"},{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"}],"categories":[{"name":"问题记录","slug":"问题记录","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"C相关","slug":"问题记录/C相关","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/C%E7%9B%B8%E5%85%B3/"}]},{"title":"解决VirtualBox无法启用嵌套分页","date":"2020-10-30T23:19:26.000Z","path":"wiki/virtualbox-log/","text":"VirtualBox 无法启用嵌套分页 解决方式开启嵌套分页: VBoxManage modifyvm &quot;虚拟机名字&quot; --nested-hw-virt on","tags":[{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://editso.github.io/tags/VirtualBox/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"VirtualBox","slug":"软件相关/VirtualBox","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/VirtualBox/"}]},{"title":"记录一次Manjaro下VirtualBox界面文字不显示,黑屏","date":"2020-10-29T23:36:16.000Z","path":"wiki/virtualbox-manjaro-log/","text":"问题截图 我的解决办法尝试了各种办法,在网上查了半天资料都没有解决这个问题,后来我去设置把外观都重置了问题得以解决,后来我通过排除的方式发现是 颜色 的问题,修改 颜色 后问题解决 位置: 系统设置 &gt; 外观 &gt; 颜色","tags":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://editso.github.io/tags/VirtualBox/"},{"name":"Kde","slug":"Kde","permalink":"http://editso.github.io/tags/Kde/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/categories/Linux/"},{"name":"Manjaro","slug":"Linux/Manjaro","permalink":"http://editso.github.io/categories/Linux/Manjaro/"}]},{"title":"Manjaro系统的使用","date":"2020-10-28T10:41:21.000Z","path":"wiki/manjaro-use/","text":"简单介绍:Manjaro是一款基于Arch Linux、对用户友好、全球排名非常靠前的Linux发行版来源:Linux265","tags":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"系统","slug":"系统","permalink":"http://editso.github.io/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"开源","slug":"开源","permalink":"http://editso.github.io/tags/%E5%BC%80%E6%BA%90/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/categories/Linux/"},{"name":"Manjaro","slug":"Linux/Manjaro","permalink":"http://editso.github.io/categories/Linux/Manjaro/"}]},{"title":"记录一次Flutter run时出现的错误","date":"2020-05-20T22:05:29.000Z","path":"wiki/flutter-log/","text":"使用Flutter run 出现错误: 错误原因:镜像：https://storage.googleapis.com/download.flutter.io 访问不了 解决办法：更改仓库地址为 https://storage.flutter-io.cn/download.flutter.io allprojects &#123; repositories &#123; google() jcenter() maven &#123;url &quot;https://storage.flutter-io.cn/download.flutter.io&quot;&#125; &#125; &#125;```","tags":[{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"踩坑","slug":"踩坑","permalink":"http://editso.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Flutter","slug":"Flutter","permalink":"http://editso.github.io/tags/Flutter/"}],"categories":[{"name":"问题记录","slug":"问题记录","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Flutter","slug":"问题记录/Flutter","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Flutter/"}]},{"title":"桌面壁纸网站","date":"2019-12-28T13:55:00.000Z","path":"wiki/wallpaper/","text":"桌面壁纸网站 wallpapershome","tags":[{"name":"Theme","slug":"Theme","permalink":"http://editso.github.io/tags/Theme/"},{"name":"壁纸","slug":"壁纸","permalink":"http://editso.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"Desktop","slug":"Desktop","permalink":"http://editso.github.io/tags/Desktop/"}],"categories":[{"name":"杂项","slug":"杂项","permalink":"http://editso.github.io/categories/%E6%9D%82%E9%A1%B9/"}]},{"title":"ubuntu使用","date":"2019-12-24T17:05:21.000Z","path":"wiki/ubuntu-theme/","text":"Ubuntu使用切换阿里云软件源:编辑： sudo vim /etc/apt/sources.list 将默认的：http://archive.ubuntu.com/ 替换为： http://mirrors.aliyun.com 配置如下: 1234567891011121314deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 参考 Ubuntu 镜像 谷歌拼音输入法: sudo apt install fcitx fcitx-googlepinyin 设置输入法:设置&gt;区域与语言&gt;管理已安装的语言&gt;键盘输入法系统&gt;fcitx注销电脑配置重新登录, 在应用程序中找到fcitx配置或搜索配置谷歌输入法 主题美化工具安装：sudo apt install gnome-tweak-tool gnome-shell-extensionsshell: ChromeOS shell theme鼠标指针: Bibatadock栏： dash-to-dock","tags":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"Theme","slug":"Theme","permalink":"http://editso.github.io/tags/Theme/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://editso.github.io/tags/Ubuntu/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/categories/Linux/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","permalink":"http://editso.github.io/categories/Linux/Ubuntu/"}]},{"title":"记录一次使用vue-cli4.0 创建项目时非常慢问题","date":"2019-12-19T11:07:51.000Z","path":"wiki/vue-log/","text":"记录一次使用vue-cli4.0 创建项目时非常慢问题使用vue时在创建项目遇到创建项目非常慢然后各种办法都不行, 最后问了我朋友,朋友告诉我是我的npm node vue版本过低当时想只需要更新npm vue版本就行后还是下载很慢,最后将node更新故问题解决 解决步骤: 更新 npm: npm install npm@latest -g 安装 n: npm install -g n --force 更新 node: sudo n stable 下载最新 vue: sudo npm install -g @vue/cli更新好后重启终端问题解决! 命令整合:1234npm install npm@latest -g npm install -g n --force sudo n stable sudo npm install -g @vue/cli","tags":[{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"踩坑记","slug":"踩坑记","permalink":"http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"}],"categories":[{"name":"问题记录","slug":"问题记录","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"前端相关","slug":"问题记录/前端相关","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"}]},{"title":"mysql8.0踩坑","date":"2019-12-19T10:53:06.000Z","path":"wiki/mysql-log/","text":"Mysql8.0采坑密码无法使用在服务器中安装mysql8.0数据库修改密码发现无法使用update语句修改,于是百度了一番参考了MYSQL8.0以上版本正确修改ROOT密码由此问题解决 解决方法: 使用mysql初始生成的密码登录到数据库(密码在数据库产生的日志文件中, 可查看/etc/my.cnf中的log-error指向的文件) 登录到数据库 mysql -uroot -p&#39;首次初始化数据库产生的密码&#39; 登录执行 alter user &#39;root&#39;@localhost identified by &#39;new password&#39;; 执行成功后刷新数据库 flush privileges;问题成功解决 连接出现 cryptography is required for sha256_password or caching_sha2_password**解决方法: 首先查询一下数据库user表中连接时报错的用户与主机 mysql&gt; select user,plugin,host from mysql.user; +------------------+-----------------------+-----------+ | user | plugin | host | +------------------+-----------------------+-----------+ | root | mysql_native_password | % | | mysql.infoschema | caching_sha2_password | localhost | | mysql.session | caching_sha2_password | localhost | | mysql.sys | caching_sha2_password | localhost | | root | mysql_native_password | localhost | +------------------+-----------------------+-----------+ 5 rows in set (0.00 sec) % 表示通配符 查询得出 plugin 为 caching_sha2_password 就将它改为 mysql_native_password执行如下命令: alter user &#39;your account&#39;@&#39;your host&#39; identified with mysql_native_password by &#39;your password&#39; flush privileges #刷新权限 重新连接， 问题解决 。参考了msql8.0官方文档可插拔身份验证 不成功其他解决方法 参考 mysql报错RuntimeError: cryptography is required for sha256_password or caching_sha2_p ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新一下用户的密码 FLUSH PRIVILEGES; #刷新权限 alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;; # 再次重置密码 重启服务,问题解决","tags":[{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"Mysql","slug":"Mysql","permalink":"http://editso.github.io/tags/Mysql/"},{"name":"踩坑记","slug":"踩坑记","permalink":"http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://editso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"Mysql","slug":"软件相关/Mysql","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Mysql/"}]},{"title":"记录一次服务器免密登录失效问题","date":"2019-12-19T10:32:57.000Z","path":"wiki/ssh-log/","text":"SSH免密登陆失效在本地使用ssh-keygen生成密钥 ssh-keygen -t rsa 将本地~/.ssh/id_rsa.pub使用ssh-copy-id复制到user@hostname下 ssh-copy-id -i ~/.ssh/id_rsa.pub user@hostname 成功后我尝试使用ssh user@hostname连接发现还是需要输入密码 解决办法服务端~/.ssh文件夹权限必须是 700 chmod 700 ~/.ssh 服务端~/.ssh/authorized_keys权限必须是 600 chmod 600 ~/.ssh/autohrized_keys","tags":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"踩坑记","slug":"踩坑记","permalink":"http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"name":"SSH","slug":"SSH","permalink":"http://editso.github.io/tags/SSH/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/categories/Linux/"},{"name":"SSH","slug":"Linux/SSH","permalink":"http://editso.github.io/categories/Linux/SSH/"}]},{"title":"linux系统函数学习","date":"2019-12-01T18:57:27.000Z","path":"wiki/linux-func-use/","text":"Linux系统函数学习进程程序: 死的, 只会占用磁盘空间进程: 活的,运行起来的程序,占用内存,cpu系统资源等 PCB进程控制块就是一个结构体 相关信息: 进程id, 文件描述符, 进程工作目录, *umask掩码, 信号相关信息资源, 用户id和组id, 进程状态: 初始态, 就绪态, 运行态, 挂起态, 终止态 fork()函数创建子进程, 父进程各自返回.父进程返回子进程pid, 子进程返回0头文件:unistd.h 父子进程相同:刚fork后: data段, text段, 堆, 栈, 环境变量, 宿主目录位置, 进程工作位置, 信号处理方式 父子进程不同:进程id, 返回值, 各自的父进程, 进程创建时间, 闹钟, 未决信号集 父子进程共享:读时共享,写时复制文件描述符, mmap映射区 获取进程各个id函数:getpid():获取当前进程idgetppid():获取父进程的idgetgid():获取当前组id","tags":[{"name":"C","slug":"C","permalink":"http://editso.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"编程","slug":"编程","permalink":"http://editso.github.io/tags/%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/categories/Linux/"},{"name":"API","slug":"Linux/API","permalink":"http://editso.github.io/categories/Linux/API/"}]},{"title":"makefile文件的使用","date":"2019-11-28T11:01:00.000Z","path":"wiki/makefile-use/","text":"makefile文件的使用简介makefile是一个脚本文件，将命令整合到一起来执行，提高开发效率使用它脚本名如果不指定-f参数那么脚本文件命名必须要使用 makefile or Makefile 一个规则生成目标:生成目标对应的依赖++++执行语句注意:生成语句必须是换行后缩进4个空格 两个函数*函数调用方法:$(函数名 args1, args2)$(wildcard pattern):获取所有匹配的内容，返回一个列表$(patsubst %, %, p3):获取某个列表中的所有值,并将参数1匹配到替换为参数二 三个变量$^:获取一个规则中所有的依赖$@:获取一个规则中生成的目标$&lt;:获取一个规则中第一个依赖,它还有一个特性就是在使用规则匹配时有多个依赖可以将他们都拆分开 [静态]规则匹配%:%:匹配任意的规则如: %.c:%.o表示匹配目标后缀为.c的以应依赖为.o的$(目标依赖文件) or t1,12....:%:%:在执行规则时,在执行到目标依赖文件时才会执行到该语句例如: 12345678# 规则src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))a.out:$(obj) gcc $(obj) -o $@$(obj):%.o:%c gcc $&lt; -0 $@ 其他all:表示执行的最终目标不是用它默认是第一条就是最终目标clean:执行清理语句在执行的时候使用make clean -n来显示出要被清理文件执行直接去掉-nmake -f:表示指定要执行的makefile, 如果指定了它要执行clean就需要用make -f 指定的makefile clean 来执行","tags":[{"name":"Make","slug":"Make","permalink":"http://editso.github.io/tags/Make/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"Make","slug":"软件相关/Make","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Make/"}]},{"title":"gdb调试工具的使用","date":"2019-11-27T21:48:14.000Z","path":"wiki/gdb-use/","text":"gdb调试工具的使用简介简单地说就是一个调试工具。它是一个受通用公共许可证即GPL保护的自由软件。 使用使用gdb调试工具时，在gcc打包为二进制文件时需要指定-g参数表示在该程序中添加调试语句当编译好后，执行gdb 需要被调试的程序 相关命令 list / l列出被调试程序的源代码，根据源码向指定位置设置断点显示出源代码的下一页使用 list / l break / b设置断点：break / b 行号设置条件断点：b 行号 if 条件当满足条件时才会执行，一般用在循环/递归语句 run / r运行程序不用设置断点直接执行，如果遇到程序出现错误时会显示出错的行数,可快速找到错误该命令还可以在后面添加参数，每个参数以空格分开，它表示向main函数中传入参数 n (next) / S (step)n/S 表示执行下一条指令它们的区别在于执行函数的时候，当使用n来执行的时候会直接越过函数不会进入到函数内部执行而是直接执行到下一行,而S则反之在调试时可以按需选择如何使用这两个命令gbd调试时有一个小毛病就是在进入到函数内部时如果是库函数就会报找不到那个文件所以在使用时要注意执行遇到库函数时要使用n来执行 p显示指定变量的值p 变量名 continue继续执行断点后续指令 quit退出当前调试 finish结束当前函数调用，回到调用点 set argsset args args1 args2 ..在执行程序前设置命令行参数: info b查看gdb调试表中调试的内容 ptype查看变量类型：ptype 变量 bt(backtrace)列出当前程序正存活着的栈帧它通常与frame配合使用 frame根据栈帧编号，切换栈桢它通常与bt配合使用 set follow-fork-mode [child | parent] child: 跟踪子进程 parent: 跟踪父进程 display &amp; undisplay display: 设置跟踪变量 undisplay[编号]: 取消跟踪变量 知识点栈帧: 随着函数调用而在stack上开辟的一片内存空间, 用于存放函数调用时产生的局部变量和临时值","tags":[{"name":"C","slug":"C","permalink":"http://editso.github.io/tags/C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"GDB","slug":"GDB","permalink":"http://editso.github.io/tags/GDB/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"GDB","slug":"软件相关/GDB","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GDB/"}]},{"title":"vim编辑器使用","date":"2019-11-27T16:30:34.000Z","path":"wiki/vim-use/","text":"vim 学习笔记vim三种模式 命令模式 末行模式 输入模式 命令模式 当刚刚启动vim时就为该模式命令模式 该模式下所敲击的键盘都为命令 若想切换到输入模式可敲击字母按键 i 若想切换到末行默认输入键盘中冒号 : 命令模式相关命令i: 在光标之前插入数据 I: 光标所在行的行首插入数据 a: 在光标之后插入数据 A: 光标所在行的行尾插入数据 o: 在光标所在行的下一行插入数据 O: 光标所在行的上一行数据插入数据 s: 向光标所在的那个字符插入数据并删除光标所指向的字符 S: 向光标所在行插入数据并删除当前行所有数据 h j k l: 分别代表 左/下/上/右移动 M: 光标移动到中间行 L: 光标移动到屏幕最后一行 G: 跳转到指定行 行号G:例如：移动到第二行2G gg: 跳转到首行 GG: 跳转到最后一行 gg=G: 自动格式化文本 %: 括号匹配 x: 删除光标下的字符 dw: 删除单词 D: 删除光标到行尾的所有字符 0: 光标移动到行首 $: 光标移动到行尾 d0: 删除光标到行首的所有字符 d$: 删除光标到行尾的所有字符 r: 替换光标下的字符 v: 可视, 选中某区域使用 h j k l来移动选中区域 数字dd: 删除n行 yy: 复制一行 p: 粘贴到光标下一行 P: 粘贴到光标上一行 [数字]yy: 复制多行 u ctr+r: 撤销上一步u, 反撤销ctr+r /: 查找/查找的内容 按n查找下一个 按N查找上一个 * #: 查找已知内容, 将光标移动到需要被查找的字符按 *向后查找 #向前查找 [d: 查看宏定义（前提是该宏存在） 末行模式按esc输入:进入末行模式 数字: 跳转到指定的行例如: 跳转到22行:22 s /old/new| %s /old/new| %s /old/new/g| 数字,数字s /old/new 单行替换 将光标移动到需要被替换的行:s /被替换的/替换后的 全文替换 :%s /被替换的/替换后的 只会替换每行的第一个被匹配的 全文整行替换:%s /被替换的/替换后的/g 全文替换如一行多个匹配都会被替换 区域替换:开始行,结束行s /被替换的/替换后的 替换指定区域中匹配的 sp vsp: 分割窗口 垂直分割: sp 水平分割: vsp 切换页面: ctr + ww 退出光标所在页面: q 退出所有页面: qall ctr+p|ctr+n: 上一个命令ctr+p 下一个命令ctr+n w: 保存不退出vim qw: 保存并退出 q!: 不保存退出 !: 不保存执行命令 :![执行的命令]","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Editor","slug":"Editor","permalink":"http://editso.github.io/tags/Editor/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"Vim","slug":"软件相关/Vim","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Vim/"}]},{"title":"字符串匹配算法-KMP","date":"2019-11-27T15:50:04.000Z","path":"wiki/kmp/","text":"字符串匹配算法-KMP说明kmp的一些概述不做解释了, 请参考: kmp算法 (百度百科)参考了 阮一峰的: 字符串匹配的KMP算法使用 C 语言实现的算法 部分匹配表指在一串字符串中, 前缀与后缀中所共有的字符 前缀: 不包含字符串最后一个字符 后缀: 不包含字符串第一个字符 例子:字符串 (AHABAD)**由此得出他们的部分匹配表为 A -&gt; 0 前后都没有所有共有字符数所以为 0 AH -&gt; 0 前缀: A 后缀: H 它们没有功能字符所有为 0 AHA -&gt; 1 前缀: A, AH 后缀: A, HA 它们有共有的字符 共有数为 1 AHAB -&gt; 0 前缀: A, AH, AHA 后缀: B, AB, HAB 它们没有共有字符所有为 0 AHABA -&gt; 1 前缀: A, AH, AHA, AHAB 后缀: A, BA, ABA, HABA 它们有共有字符 共有数为 1 由此得出 AHABAD 的前缀表为 0 1 2 3 4 5 A H A B A D -1 0 0 1 0 1 部分匹配表算法实现过程 C 语言 123456789101112131415161718192021222324int* prefix(char* s)&#123; /* 接收一个字符串, 返回一个部分匹配表 */ int len = strlen(s), i = 0, j = -1, *p = malloc(sizeof(int) * len); p[0] = -1; while(i &lt; len - 1)&#123; if(j == -1 || s[i] == s[j])&#123; p[++i] = ++j; continue; &#125; j = p[j]; &#125; return p;&#125; 变量 i &amp;&amp; j &amp;&amp; p 的作用 在这里 p 可以看作是一次回溯, 应为每当 if 条件不满足时 则进行一次回溯 那么此时 j 的位置就需要重置到 p[j] 部分匹配表生成过程 以字符串 AHABAD 为例 变量 A H A B A D s = AHABAD \\ A A H A \\ j = -1 -1, 0 0,-1, 0 0, 1 1, 0, -1, 0 0, 1 \\ i = 0 0, 1 1, 2 2, 3 3, 4 4, 5 \\ p[0]=-1 p[1]=0 p[2]= 0 p[3]=1 p[4]=0 p[5]=1 \\ kmp 12345678910111213141516171819202122232425//kmp匹配算法int kmpSearch(char *t, char *s)&#123; int t_len = strlen(t), s_len = strlen(s); int *p = prefix(s), m = 0, //代表母串匹配到的位置 j = 0; // 代表字符匹配到的位置 while(t_len &gt; m &amp;&amp; s_len &gt; j)&#123; //j == -1 那么代表不和任何匹配直接向后移动以为 if(j == -1 || t[m] == s[j])&#123; m++; j++; continue; &#125; //当不相等时, 就去查询部分匹配表 j = p[j]; &#125; if (j == s_len) //返回匹配到的索引位置 return m - j; return -1;&#125; 完整代码所需头文件: string.h stdlib.h 12345678910111213141516171819202122232425262728293031323334353637383940414243//部分匹配表算法int* prefix(char* s)&#123; //prefix table int len = strlen(s), i = 0, j = -1, *p = malloc(sizeof(int) * len); p[0] = -1; while(i &lt; len - 1)&#123; if(j == -1 || s[i] == s[j])&#123; p[++i] = ++j; continue; &#125; j = p[j]; &#125; return p;&#125;//kmpint kmpSearch(char *t, char *s)&#123; int t_len = strlen(t), s_len = strlen(s); int *p = prefix(s), m = 0, j = 0; while(t_len &gt; m &amp;&amp; s_len &gt; j)&#123; if(j == -1 || t[m] == s[j])&#123; m++; j++; continue; &#125; j = p[j]; &#125; if (j == s_len) return m - j; return -1;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://editso.github.io/tags/Algorithm/"},{"name":"编程","slug":"编程","permalink":"http://editso.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Code","slug":"Code","permalink":"http://editso.github.io/tags/Code/"}],"categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://editso.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}]},{"title":"GCC 常见命令参数的使用","date":"2019-11-27T14:52:16.000Z","path":"wiki/gcc-use/","text":"GCC 常见命令参数的使用相关参数 -v 查看版本号 -I (大写) 指定头文件目录, 该命令随后就是目录没有空格 -c 只做生成.o文件(预处理-&gt;编译-&gt;汇编) 不做链接 -E 生成预处理文件 -S 检查语法,生成汇编文件(预处理-&gt;编译) -D 在编译时定义宏 -g 编译时添加调试语句 -Wall 显示所有调试信息 -On （n = 1~3） 编译优化 值越大优化得越多","tags":[{"name":"C","slug":"C","permalink":"http://editso.github.io/tags/C/"},{"name":"GCC","slug":"GCC","permalink":"http://editso.github.io/tags/GCC/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"GCC","slug":"软件相关/GCC","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GCC/"}]},{"title":"GIT仓库的使用","date":"2019-07-31T09:10:00.000Z","path":"wiki/git-use/","text":"GIT仓库的使用配置基本信息 git config --global user.name &quot;用户名&quot; git config --global user.email &quot;邮箱&quot; 克隆分支 git clone xxxxxx.git 同步分支 git clone xxxxxx.git - b 分支名 上传提交信息 git commit -m &quot;提交信息&quot; 将本地的库链接到仓库 git remote add origin xxxxx.git 查看代码的修改状态 git status 红色或绿色部分字体是工程内的发生修改的状态标识 modified 代表文件和上一版本相比，有过修改 new file 代表文件是新增加的 deleted 代表文件被删除了，提交成功后，文件将从repository中删除 untracked file 一般都是新增加的文件夹 查看代码的修改内容 git diff &lt;filename&gt; 添加一个文件 git add &lt;filename&gt; 删除一个不需要的文件 git rm &lt;filename&gt; 增加全部需要上传的文件 git add --all git add -A git add . 如果发现有文件漏提或注释有误，使用amend修正 git commit --amend 注意：使用commit命令只是将修改提交到本地仓库 同步到服务器前先需要将服务器代码同步到本地 git pull 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步 git checkout -- &lt;有冲突的文件路径&gt; 同步到服务器 git push origin &lt;本地分支名&gt; 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"仓库","slug":"仓库","permalink":"http://editso.github.io/tags/%E4%BB%93%E5%BA%93/"},{"name":"GIT","slug":"GIT","permalink":"http://editso.github.io/tags/GIT/"}],"categories":[{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"GIT","slug":"软件相关/GIT","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GIT/"}]}],"categories":[{"name":"汇编学习","slug":"汇编学习","permalink":"http://editso.github.io/categories/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"},{"name":"Windows","slug":"Windows","permalink":"http://editso.github.io/categories/Windows/"},{"name":"PE","slug":"Windows/PE","permalink":"http://editso.github.io/categories/Windows/PE/"},{"name":"问题记录","slug":"问题记录","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"C相关","slug":"问题记录/C相关","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/C%E7%9B%B8%E5%85%B3/"},{"name":"Grub","slug":"问题记录/Grub","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Grub/"},{"name":"算法学习","slug":"算法学习","permalink":"http://editso.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"软件相关","slug":"软件相关","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"VirtualBox","slug":"软件相关/VirtualBox","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/VirtualBox/"},{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/categories/Linux/"},{"name":"Manjaro","slug":"Linux/Manjaro","permalink":"http://editso.github.io/categories/Linux/Manjaro/"},{"name":"Flutter","slug":"问题记录/Flutter","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Flutter/"},{"name":"杂项","slug":"杂项","permalink":"http://editso.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","permalink":"http://editso.github.io/categories/Linux/Ubuntu/"},{"name":"前端相关","slug":"问题记录/前端相关","permalink":"http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"},{"name":"Mysql","slug":"软件相关/Mysql","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Mysql/"},{"name":"SSH","slug":"Linux/SSH","permalink":"http://editso.github.io/categories/Linux/SSH/"},{"name":"API","slug":"Linux/API","permalink":"http://editso.github.io/categories/Linux/API/"},{"name":"Make","slug":"软件相关/Make","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Make/"},{"name":"GDB","slug":"软件相关/GDB","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GDB/"},{"name":"Vim","slug":"软件相关/Vim","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Vim/"},{"name":"GCC","slug":"软件相关/GCC","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GCC/"},{"name":"GIT","slug":"软件相关/GIT","permalink":"http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GIT/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"http://editso.github.io/tags/ASM/"},{"name":"Arm","slug":"Arm","permalink":"http://editso.github.io/tags/Arm/"},{"name":"Arm64","slug":"Arm64","permalink":"http://editso.github.io/tags/Arm64/"},{"name":"Windows","slug":"Windows","permalink":"http://editso.github.io/tags/Windows/"},{"name":"PE","slug":"PE","permalink":"http://editso.github.io/tags/PE/"},{"name":"C","slug":"C","permalink":"http://editso.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://editso.github.io/tags/Linux/"},{"name":"GCC","slug":"GCC","permalink":"http://editso.github.io/tags/GCC/"},{"name":"GRUB","slug":"GRUB","permalink":"http://editso.github.io/tags/GRUB/"},{"name":"Manjaro","slug":"Manjaro","permalink":"http://editso.github.io/tags/Manjaro/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://editso.github.io/tags/Algorithm/"},{"name":"Acm","slug":"Acm","permalink":"http://editso.github.io/tags/Acm/"},{"name":"CPP","slug":"CPP","permalink":"http://editso.github.io/tags/CPP/"},{"name":"日志","slug":"日志","permalink":"http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://editso.github.io/tags/VirtualBox/"},{"name":"Kde","slug":"Kde","permalink":"http://editso.github.io/tags/Kde/"},{"name":"系统","slug":"系统","permalink":"http://editso.github.io/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"开源","slug":"开源","permalink":"http://editso.github.io/tags/%E5%BC%80%E6%BA%90/"},{"name":"踩坑","slug":"踩坑","permalink":"http://editso.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Flutter","slug":"Flutter","permalink":"http://editso.github.io/tags/Flutter/"},{"name":"Theme","slug":"Theme","permalink":"http://editso.github.io/tags/Theme/"},{"name":"壁纸","slug":"壁纸","permalink":"http://editso.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"Desktop","slug":"Desktop","permalink":"http://editso.github.io/tags/Desktop/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://editso.github.io/tags/Ubuntu/"},{"name":"踩坑记","slug":"踩坑记","permalink":"http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"name":"Mysql","slug":"Mysql","permalink":"http://editso.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://editso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSH","slug":"SSH","permalink":"http://editso.github.io/tags/SSH/"},{"name":"编程","slug":"编程","permalink":"http://editso.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Make","slug":"Make","permalink":"http://editso.github.io/tags/Make/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"GDB","slug":"GDB","permalink":"http://editso.github.io/tags/GDB/"},{"name":"Editor","slug":"Editor","permalink":"http://editso.github.io/tags/Editor/"},{"name":"Code","slug":"Code","permalink":"http://editso.github.io/tags/Code/"},{"name":"仓库","slug":"仓库","permalink":"http://editso.github.io/tags/%E4%BB%93%E5%BA%93/"},{"name":"GIT","slug":"GIT","permalink":"http://editso.github.io/tags/GIT/"}]}