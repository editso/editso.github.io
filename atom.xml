<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>editso</title>
  
  
  <link href="http://editso.github.io/atom.xml" rel="self"/>
  
  <link href="http://editso.github.io/"/>
  <updated>2023-06-29T10:21:29.659Z</updated>
  <id>http://editso.github.io/</id>
  
  <author>
    <name>zy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Arm64汇编记录</title>
    <link href="http://editso.github.io/wiki/arm64/"/>
    <id>http://editso.github.io/wiki/arm64/</id>
    <published>2023-06-29T10:37:00.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关指令记录"><a href="#相关指令记录" class="headerlink" title="相关指令记录"></a>相关指令记录</h1><h2 id="ARDP"><a href="#ARDP" class="headerlink" title="ARDP"></a>ARDP</h2><blockquote><p>ADRP &lt;reg&gt; &lt;imm&gt;  </p></blockquote><ol><li>从PC相对地址到4KB页添加一个直接值</li><li>将当前<code>pc</code>地址<code>低12位置零</code>, 并加上<code>立即数左移12位后</code>的值</li></ol><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PC        = 0xe7b27341c7b0</span><br><span class="line">reg = x16</span><br><span class="line">imm = 866</span><br><span class="line"></span><br><span class="line">; adrp x16, 866</span><br><span class="line"></span><br><span class="line">x16       = (0xe7b27341c7b0 &amp; (~0xFFF)) + (866 &lt;&lt; 12)</span><br><span class="line">          = 0xe7b27377e000</span><br></pre></td></tr></table></figure><h2 id="CBZ"><a href="#CBZ" class="headerlink" title="CBZ"></a>CBZ</h2><blockquote><p>CBZ &lt;reg&gt; &lt;imm&gt;</p></blockquote><ol><li>将寄存器的值与<code>0</code>比较, 如过<code>相等则跳转</code>到相对<code>pc</code> <code>+/-1MB</code>的位置</li></ol><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reg =  x0</span><br><span class="line">imm =  0xe7b273333c84</span><br><span class="line"></span><br><span class="line">; cbz x0, 0xe7b273333c84</span><br><span class="line"></span><br><span class="line">if (x0 == 0 ) goto 0xe7b273333c84</span><br><span class="line">...continue</span><br></pre></td></tr></table></figure><h2 id="XZR"><a href="#XZR" class="headerlink" title="XZR"></a>XZR</h2><p>用于64位(8字节)置零操做</p><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 将x20寄存器置零</span><br><span class="line">; mov x20, xzr</span><br><span class="line"></span><br><span class="line">x20 = 0</span><br></pre></td></tr></table></figure><h2 id="LDP"><a href="#LDP" class="headerlink" title="LDP"></a>LDP</h2><blockquote><p>LDP &lt;reg1&gt;, &lt;reg2&gt;, [reg3], &lt;imm&gt;  </p></blockquote><ol><li>将<code>reg3</code>地址里面的值加载到<code>reg1</code>和<code>reg2</code></li><li>然后更新<code>reg3</code>的值, <code>reg3 += imm</code></li></ol><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sp = uint64[]&#123; 2, 3 &#125;</span><br><span class="line"></span><br><span class="line">; ldp, x0, x1, [sp], #0x10</span><br><span class="line"></span><br><span class="line">x0 =  *sp</span><br><span class="line">   = 2</span><br><span class="line">x1 = *(sp + 8)</span><br><span class="line">   = 3</span><br><span class="line">sp = sp + 16</span><br></pre></td></tr></table></figure><h2 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h2><blockquote><p>STP &lt;reg1&gt;, &lt;reg2&gt;, [reg3, imm]!</p></blockquote><ol><li>将<code>reg1</code>,<code>reg2</code>中的值存入 <code>reg3 + imm</code>的地址里面, 并更新 <code>reg3</code>的值 <code>reg3 += imm</code></li></ol><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x1 = 1</span><br><span class="line">x2 = 2</span><br><span class="line"></span><br><span class="line">; stp x1, x2, [sp, #-10]!</span><br><span class="line"></span><br><span class="line">*(sp - 16)       = x1</span><br><span class="line">                 = 1</span><br><span class="line">*(sp - 16 - 8)   = x2</span><br><span class="line">                 = 2</span><br><span class="line">sp               = sp - 16</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相关指令记录&quot;&gt;&lt;a href=&quot;#相关指令记录&quot; class=&quot;headerlink&quot; title=&quot;相关指令记录&quot;&gt;&lt;/a&gt;相关指令记录&lt;/h1&gt;&lt;h2 id=&quot;ARDP&quot;&gt;&lt;a href=&quot;#ARDP&quot; class=&quot;headerlink&quot; title=&quot;A</summary>
      
    
    
    
    <category term="汇编学习" scheme="http://editso.github.io/categories/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ASM" scheme="http://editso.github.io/tags/ASM/"/>
    
    <category term="Arm" scheme="http://editso.github.io/tags/Arm/"/>
    
    <category term="Arm64" scheme="http://editso.github.io/tags/Arm64/"/>
    
  </entry>
  
  <entry>
    <title>线程局部存储(TLS)</title>
    <link href="http://editso.github.io/wiki/windows-thread-local/"/>
    <id>http://editso.github.io/wiki/windows-thread-local/</id>
    <published>2022-02-12T20:44:14.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程局部存储"><a href="#什么是线程局部存储" class="headerlink" title="什么是线程局部存储?"></a>什么是线程局部存储?</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。这种对象的链接性（linkage）可以是静态的也可是外部的。</a><br>在<code>Windows</code>上<code>TLS</code>的存储结构为:<br><img src="/images/tls/tls.png"></p><h2 id="静态TLS"><a href="#静态TLS" class="headerlink" title="静态TLS"></a>静态TLS</h2><p>静态<code>TLS</code>需要使用 <code>__declspace(thread) 变量</code> 进行标识, 当编译器进行打包时会将它存储到特定的节中(<code>.tls</code>)它将会变成一个<code>tls</code>模板, 在程序进行线程创建时将会开辟一个足够大的空间将<code>tls模板</code>数据复制进去(<code>tls副本</code>), 所以每个线程访问与修改它时互不干扰.</p><h2 id="PE加壳带静态TLS如何修复"><a href="#PE加壳带静态TLS如何修复" class="headerlink" title="PE加壳带静态TLS如何修复?"></a>PE加壳带静态TLS如何修复?</h2><p>这个问题我也是折腾了很久, 在网上找了很久的资料基本上都是讲的<code>TLS Callback</code>,反调试相关的, 然后看了<code>&lt;&lt;Windows PE权威指南&gt;&gt;</code>虽然有说静态TL是如何存储的,但是没有例子,只是说了下 不过已经知道<code>TLS</code>是存储在哪儿的 那不就好办了? 书上说的是<br><code>“当创建线程时，加载器通过将线程环境块（TEB）的地址放入FS寄存器来传递线程的TLS数组地址。距TEB开头0x2C的位置处的字段ThreadLocalStoragePointer指向TLS数组”</code> 书上这里说的是32位的, 64位的可以自己去查 <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/index.htm">TEB相关字段偏移</a> 也就是说只要我将 <code>TLS</code>模板中的数据先写到一块内存中, 然后将数据首地址写入这个数组中就好了?<br>跟着书上说的我去试了下, 发现有大坑!!!, 然后我仔细想了想了<code>TEB</code>在每个线程都是不一样的, 所以我加进去的只是<code>TLS副本</code>也就是说我只给我当前获取到<code>TEB</code>的那个线程加进去了, 其他的还是没有然后这样会导致我的程序在开新线程的时候获取不到<code>TLS</code>数据… 离谱吧, 所以在程序中不开线程访问是莫问题滴… 但是对于简单的程序还好, 要是遇到网络相关操作的一个线程?? 所以这个算只是解决了半个问题??.. 现在大概是知道问题所在, 我修改的只是<code>TLS</code>副本, 所以我只需要修改加载器的<code>TLS</code>模板数据就可以了? (也就是说将加载器<code>TLS</code>数据模板替换为我主程序的模板数据).  但是我怎么知道加壳程序<code>TLS</code>模板存储位置呢.. 带着这个问题又去查资料, 果然在<code>Github</code>找到一个外国佬写的<a href="https://github.com/polycone/pe-loader">pe_loader</a>而且它支持<code>静态TLS</code>的加载, 所以我去看了他的代码 <a href="https://github.com/polycone/pe-loader/blob/master/loader/src/loader/tls_support.cpp">tls_support.cpp</a></p><p><img src="/images/tls/github_tls_001.png"><br><img src="/images/tls/github_tls_002.png"></p><p>他获取这个模板数据首地址是硬搜的, 先拿到<code>TLS</code>表然后去内存匹配<br>芜湖~ 这不就是我想要的? 好像他的代码挺复杂的, 不过已经知道办法了只需要撸代码了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码就不贴了, 我写的代码垃圾.. 就截个图吧<br><img src="/images/tls/github_tls_003.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">线程局部存储</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/thread-local-storage">线程局部存储结构图</a></li><li><a href="https://github.com/polycone/pe-loader/blob/master/loader/src/loader/tls_support.cpp">找首地址</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程局部存储&quot;&gt;&lt;a href=&quot;#什么是线程局部存储&quot; class=&quot;headerlink&quot; title=&quot;什么是线程局部存储?&quot;&gt;&lt;/a&gt;什么是线程局部存储?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%</summary>
      
    
    
    
    <category term="Windows" scheme="http://editso.github.io/categories/Windows/"/>
    
    <category term="PE" scheme="http://editso.github.io/categories/Windows/PE/"/>
    
    
  </entry>
  
  <entry>
    <title>PE头文件学习笔记</title>
    <link href="http://editso.github.io/wiki/pe/"/>
    <id>http://editso.github.io/wiki/pe/</id>
    <published>2021-11-05T13:01:22.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可移植可执行"><a href="#可移植可执行" class="headerlink" title="可移植可执行"></a><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%8F%AF%E6%89%A7%E8%A1%8C">可移植可执行</a></h2><ol><li>是一种用于可执行文件、目标文件和动态链接库的文件格式，主要使用在32位和64位的Windows操作系统上。<code>可移植的</code>是指该文件格式的通用性，可用于许多种不同的操作系统和体系结构中。PE文件格式封装了Windows操作系统加载可执行程序代码时所必需的一些信息。这些信息包括动态链接库、API导入和导出表、资源管理数据和线程局部存储数据。在Windows NT操作系统中，PE文件格式主要用于EXE文件、DLL文件、.sys（驱动程序）和其他文件类型。可扩展固件接口（EFI）技术规范书中说明PE格式是EFI环境中的标准可执行文件格式。开头为DOS头部。</li><li>PE格式是由Unix中的COFF格式修改而来的。在Windows开发环境中，PE格式也称为PE/COFF格式。</li></ol><h2 id="DOS头-winnt-h"><a href="#DOS头-winnt-h" class="headerlink" title="DOS头 winnt.h"></a><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#ms-dos-stub-image-only">DOS头</a> <code>winnt.h</code></h2><h3 id="结构体信息"><a href="#结构体信息" class="headerlink" title="结构体信息"></a>结构体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">    WORD   e_magic;                     // * Magic number </span><br><span class="line">    WORD   e_cblp;                      // Bytes on last page of file</span><br><span class="line">    WORD   e_cp;                        // Pages in file</span><br><span class="line">    WORD   e_crlc;                      // Relocations</span><br><span class="line">    WORD   e_cparhdr;                   // Size of header in paragraphs</span><br><span class="line">    WORD   e_minalloc;                  // Minimum extra paragraphs needed</span><br><span class="line">    WORD   e_maxalloc;                  // Maximum extra paragraphs needed</span><br><span class="line">    WORD   e_ss;                        // Initial (relative) SS value</span><br><span class="line">    WORD   e_sp;                        // Initial SP value</span><br><span class="line">    WORD   e_csum;                      // Checksum</span><br><span class="line">    WORD   e_ip;                        // Initial IP value</span><br><span class="line">    WORD   e_cs;                        // Initial (relative) CS value</span><br><span class="line">    WORD   e_lfarlc;                    // File address of relocation table</span><br><span class="line">    WORD   e_ovno;                      // Overlay number</span><br><span class="line">    WORD   e_res[4];                    // Reserved words</span><br><span class="line">    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)</span><br><span class="line">    WORD   e_oeminfo;                   // OEM information; e_oemid specific</span><br><span class="line">    WORD   e_res2[10];                  // Reserved words</span><br><span class="line">    LONG   e_lfanew;                    // * File address of new exe header</span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重要字段说明"><a href="#重要字段说明" class="headerlink" title="重要字段说明"></a>重要字段说明</h3><ol><li><strong>e_magic</strong>: 4D5A<br> 该字段标识是否是一个PE文件以</li><li><strong>e_lfanew</strong>: –<br> 指向 NT头(<strong>IMAGE_NT_HEADER</strong>) 起始地址</li></ol><h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>NT在64和32结构没有发生变法, 只是字段类型长度有变</p><h3 id="结构体信息-1"><a href="#结构体信息-1" class="headerlink" title="结构体信息"></a>结构体信息</h3><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32">x86</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64">x64</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS64 &#123;</span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><h3 id="重要字段说明-1"><a href="#重要字段说明-1" class="headerlink" title="重要字段说明"></a>重要字段说明</h3><ol><li><strong>Signature</strong>: 5045<br> 4字节PE标识</li></ol><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">文件头</a></h2><h3 id="结构体信息-2"><a href="#结构体信息-2" class="headerlink" title="结构体信息"></a>结构体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">  WORD  Machine;              //  IMAGE_FILE_MACHINE_I386(0x014c) , IMAGE_FILE_MACHINE_IA64(0x0200), IMAGE_FILE_MACHINE_AMD64(0x8664)</span><br><span class="line">  WORD  NumberOfSections;     // *</span><br><span class="line">  DWORD TimeDateStamp;        // - </span><br><span class="line">  DWORD PointerToSymbolTable; // -</span><br><span class="line">  DWORD NumberOfSymbols;      // - </span><br><span class="line">  WORD  SizeOfOptionalHeader; // *</span><br><span class="line">  WORD  Characteristics;      // *</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><h3 id="重要字段说明-2"><a href="#重要字段说明-2" class="headerlink" title="重要字段说明"></a>重要字段说明</h3><ol><li><p><strong>NumberOfSections</strong><br> 节数量</p></li><li><p><strong>SizeOfOptionalHeader</strong><br> 可选PE头的大小</p></li><li><p><strong>Characteristics</strong><br> 属性信息</p></li></ol><h2 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h2><h3 id="结构体信息-3"><a href="#结构体信息-3" class="headerlink" title="结构体信息"></a>结构体信息</h3><h4 id="x86-1"><a href="#x86-1" class="headerlink" title="x86"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">x86</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  DWORD                BaseOfData;</span><br><span class="line">  DWORD                ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  DWORD                SizeOfStackReserve;</span><br><span class="line">  DWORD                SizeOfStackCommit;</span><br><span class="line">  DWORD                SizeOfHeapReserve;</span><br><span class="line">  DWORD                SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><h4 id="x64-1"><a href="#x64-1" class="headerlink" title="x64"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header64">x64</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER64 &#123;</span><br><span class="line">  WORD                 Magic;                       // *</span><br><span class="line">  BYTE                 MajorLinkerVersion;          // -</span><br><span class="line">  BYTE                 MinorLinkerVersion;          // -</span><br><span class="line">  DWORD                SizeOfCode;                  // -</span><br><span class="line">  DWORD                SizeOfInitializedData;       // -</span><br><span class="line">  DWORD                SizeOfUninitializedData;     // -</span><br><span class="line">  DWORD                AddressOfEntryPoint;         // *</span><br><span class="line">  DWORD                BaseOfCode;                  // -</span><br><span class="line">  ULONGLONG            ImageBase;                   // *</span><br><span class="line">  DWORD                SectionAlignment;            // *</span><br><span class="line">  DWORD                FileAlignment;               // *</span><br><span class="line">  WORD                 MajorOperatingSystemVersion; // -</span><br><span class="line">  WORD                 MinorOperatingSystemVersion; // -</span><br><span class="line">  WORD                 MajorImageVersion;           // -</span><br><span class="line">  WORD                 MinorImageVersion;           // -</span><br><span class="line">  WORD                 MajorSubsystemVersion;       // -</span><br><span class="line">  WORD                 MinorSubsystemVersion;       // -</span><br><span class="line">  DWORD                Win32VersionValue;           // -</span><br><span class="line">  DWORD                SizeOfImage;                 // *</span><br><span class="line">  DWORD                SizeOfHeaders;               // *</span><br><span class="line">  DWORD                CheckSum;                    // -</span><br><span class="line">  WORD                 Subsystem;                   // -</span><br><span class="line">  WORD                 DllCharacteristics;          // -</span><br><span class="line">  ULONGLONG            SizeOfStackReserve;          // -</span><br><span class="line">  ULONGLONG            SizeOfStackCommit;           // -</span><br><span class="line">  ULONGLONG            SizeOfHeapReserve;           // -</span><br><span class="line">  ULONGLONG            SizeOfHeapCommit;            // -</span><br><span class="line">  DWORD                LoaderFlags;                 // -</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;         // -</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><h3 id="重要字段说明-3"><a href="#重要字段说明-3" class="headerlink" title="重要字段说明"></a>重要字段说明</h3><ol><li><p><strong>Magic</strong>:</p><ul><li>IMAGE_NT_OPTIONAL_HDR32_MAGIC: 0x10b<br>  32位可执行文件</li><li>IMAGE_NT_OPTIONAL_HDR64_MAGIC: 0x20b<br>  64位可执行文件</li><li>IMAGE_ROM_OPTIONAL_HDR_MAGIC: 0x107<br>  ROM文件</li></ul></li><li><p><strong>AddressOfEntryPoint</strong>:<br> 存储入口函数偏移, 该值只是一个偏移, 真实地址需要加上 <strong>ImageBase</strong></p></li><li><p><strong>ImageBase</strong>:</p><ul><li>在内存中加载的首地址, 该值是<code>64K</code>字节的倍数</li><li>DLL 的默认值为 0x10000000。应用程序的默认值为0x00400000，但0x00010000的 Windows CE 除外</li></ul></li><li><p><strong>SectionAlignment</strong>:</p><ul><li>在内存中加载后节表应该按多少字节对齐</li></ul></li><li><p><strong>FileAlignment</strong>:</p><ul><li>在文件中应该按多少字节对齐, 默认按<code>512K</code>对齐</li></ul></li><li><p><strong>SizeOfImage</strong>:</p><ul><li>加载到内存中的总大小</li></ul></li><li><p><strong>SizeOfHeaders</strong>:</p><ul><li>PE头总大小, <strong>包括节表</strong></li></ul></li></ol><h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header">节表</a></h2><p>节表中定义了相关数据开始与结束信息 <em>(如: 代码段, 数据段, …)</em>, 它很重要,但节表中的值都是RAV 也就是拉伸后的<code>偏移地址</code></p><h3 id="结构体信息-4"><a href="#结构体信息-4" class="headerlink" title="结构体信息"></a>结构体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];  // *</span><br><span class="line">  union &#123;                              </span><br><span class="line">    DWORD PhysicalAddress;              </span><br><span class="line">    DWORD VirtualSize;                  </span><br><span class="line">  &#125; Misc;                               // *</span><br><span class="line">  DWORD VirtualAddress;                 // *</span><br><span class="line">  DWORD SizeOfRawData;                  // *</span><br><span class="line">  DWORD PointerToRawData;               // *</span><br><span class="line">  DWORD PointerToRelocations;           // -</span><br><span class="line">  DWORD PointerToLinenumbers;           // -</span><br><span class="line">  WORD  NumberOfRelocations;            // -</span><br><span class="line">  WORD  NumberOfLinenumbers;            // -</span><br><span class="line">  DWORD Characteristics;                // *</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><h3 id="重要字段说明-4"><a href="#重要字段说明-4" class="headerlink" title="重要字段说明"></a>重要字段说明</h3><ol><li><strong>Name</strong>:<br> 节表名称, 注意它不会以0结尾, 所以在获取节表名称时需要注意</li><li><strong>Misc</strong>:<br> 它在内存中加载后的大小</li><li><strong>VirtualAddress</strong>:<br> 内存中的偏移<code>(RVA)</code></li><li><strong>SizeOfRawData</strong>:<br> 节区数据大小, <code>Misc</code> 中的数据可能比它大</li><li><strong>PointerToRawData</strong>:<br> 文件偏移地址<code>(FOV)</code></li></ol><h2 id="目录表"><a href="#目录表" class="headerlink" title="目录表"></a><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory">目录表</a></h2><p>目录表有16个, 分别为:</p><ol><li>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: 7<br> Architecture-specific data</li><li>IMAGE_DIRECTORY_ENTRY_BASERELOC: 5<br> Base relocation table</li><li>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: 11<br> Bound import directory</li><li>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: 14<br> COM descriptor table</li><li>IMAGE_DIRECTORY_ENTRY_DEBUG: 6<br> Debug directory</li><li>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: 13<br> Delay import table</li><li>IMAGE_DIRECTORY_ENTRY_EXCEPTION: 3<br> Exception directory</li><li>IMAGE_DIRECTORY_ENTRY_EXPORT: 0<br> Export directory</li><li>IMAGE_DIRECTORY_ENTRY_GLOBALPTR: 8<br> The relative virtual address of global pointer</li><li>IMAGE_DIRECTORY_ENTRY_IAT: 12<br>Import address table</li><li>IMAGE_DIRECTORY_ENTRY_IMPORT: 1<br>Import directory</li><li>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: 10<br>Load configuration directory</li><li>IMAGE_DIRECTORY_ENTRY_RESOURCE: 2<br>Resource directory</li><li>IMAGE_DIRECTORY_ENTRY_SECURITY: 4<br>Security directory</li><li>IMAGE_DIRECTORY_ENTRY_TLS: 9<br>Thread local storage directory  </li></ol><h3 id="结构体信息-5"><a href="#结构体信息-5" class="headerlink" title="结构体信息"></a>结构体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">  DWORD VirtualAddress; // *</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><h3 id="重要字段信息说明"><a href="#重要字段信息说明" class="headerlink" title="重要字段信息说明"></a>重要字段信息说明</h3><ol><li><strong>VirtualAddress</strong>:<br> 指向各表偏移<code>(RVA)</code></li></ol><h3 id="目标表相关结构体"><a href="#目标表相关结构体" class="headerlink" title="目标表相关结构体"></a>目标表相关结构体</h3><p>这里只列出 导出表,  导入表, 重定位表</p><h4 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h4><p>导出表比较复杂, 需要理解导出方式与查找函数首地址</p><h5 id="结构体信息-6"><a href="#结构体信息-6" class="headerlink" title="结构体信息"></a>结构体信息</h5><figure class="highlight plaintext"><figcaption><span>导出表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><h5 id="重要字段说明-5"><a href="#重要字段说明-5" class="headerlink" title="重要字段说明"></a>重要字段说明</h5><ol><li><strong>Name</strong>:<br> 导出文件名称偏移地址 <code>(RVA)</code></li><li><strong>Base</strong>:<br> 需要开始</li><li><strong>NumberOfFunctions</strong>:<br> 导出函数数量</li><li><strong>NumberOfNames</strong>:<br> 以名称导出的函数数量</li><li><strong>AddressOfFunctions</strong>:<br> 导出的函数存放首地址偏移 <code>(RVA)</code></li><li><strong>AddressOfNames</strong>:<br> 以名称导出的函数存放首地址偏移<code>(RVA)</code></li><li><strong>AddressOfNameOrdinals</strong>:<br> 以名称导出的函数指向的序号地址偏移 <code>(RVA)</code></li></ol><h5 id="打印32位导出表信息列子"><a href="#打印32位导出表信息列子" class="headerlink" title="打印32位导出表信息列子"></a>打印<code>32位</code>导出表信息列子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD RvaToFov(PIMAGE_SECTION_HEADER sec, DWORD secCount, DWORD rva) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; secCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">if (sec-&gt;VirtualAddress &lt;= rva &amp;&amp; sec-&gt;VirtualAddress + sec-&gt;SizeOfRawData &gt;= rva) &#123;</span><br><span class="line">return rva - sec-&gt;VirtualAddress + sec-&gt;PointerToRawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sec++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void printExportTable(const char* dllName) &#123;</span><br><span class="line">LPBYTE lpBuffer = NULL;</span><br><span class="line">HANDLE hFile = NULL;</span><br><span class="line">DWORD fileSize = 0, readSize = 0, secCount = 0;</span><br><span class="line">LPDWORD lpExportFunctions = NULL, lpExportFunctionNames = NULL;</span><br><span class="line">LPWORD lpExportFunctionOrdinals = NULL;</span><br><span class="line">PIMAGE_DOS_HEADER lpDosHeader = NULL;</span><br><span class="line">PIMAGE_NT_HEADERS32 lpNtHeader = NULL;</span><br><span class="line">PIMAGE_SECTION_HEADER lpFirstSection = NULL;</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY lpExport = NULL;</span><br><span class="line"></span><br><span class="line">hFile = CreateFileA(dllName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line"></span><br><span class="line">if (!hFile) &#123;</span><br><span class="line">printf(&quot;读取%s失败\n&quot;, dllName);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileSize = GetFileSize(hFile, NULL);</span><br><span class="line"></span><br><span class="line">lpBuffer = (LPBYTE)VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">if (!lpBuffer) &#123;</span><br><span class="line">printf(&quot;分配内存失败 %d\n&quot;, fileSize);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!ReadFile(hFile, lpBuffer, fileSize, &amp;readSize, NULL)) &#123;</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpDosHeader = (PIMAGE_DOS_HEADER)lpBuffer;</span><br><span class="line"></span><br><span class="line">if (lpDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">printf(&quot;不是一个有效的PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpNtHeader = (PIMAGE_NT_HEADERS32)(lpBuffer + lpDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (lpNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">printf(&quot;不是一个有效的PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (lpNtHeader-&gt;OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">printf(&quot;不是一个32位PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secCount = lpNtHeader-&gt;FileHeader.NumberOfSections;</span><br><span class="line">lpFirstSection = (PIMAGE_SECTION_HEADER)((LPBYTE)&amp;lpNtHeader-&gt;OptionalHeader + lpNtHeader-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line">lpExport = lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection, </span><br><span class="line">secCount, </span><br><span class="line">lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 导出函数</span><br><span class="line">lpExportFunctions = (LPDWORD)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpExport-&gt;AddressOfFunctions</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// 导出函数名称</span><br><span class="line">lpExportFunctionNames = (LPDWORD)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpExport-&gt;AddressOfNames</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// 导出序号</span><br><span class="line">lpExportFunctionOrdinals = (LPWORD)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpExport-&gt;AddressOfNameOrdinals</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">printf(&quot;导出文件名称: %s\n&quot;, lpBuffer + RvaToFov(lpFirstSection, secCount, lpExport-&gt;Name));</span><br><span class="line">printf(&quot;导出函数总数: 0x%x\n&quot;, lpExport-&gt;NumberOfFunctions);</span><br><span class="line">printf(&quot;导出函数名称总数: 0x%x\n&quot;, lpExport-&gt;NumberOfNames);</span><br><span class="line"></span><br><span class="line">for (int i = 0, j = 0; i &lt; lpExport-&gt;NumberOfFunctions; i++, j = 0) &#123;</span><br><span class="line"></span><br><span class="line">for (; j &lt; lpExport-&gt;NumberOfNames; j++) &#123;</span><br><span class="line">if (i == lpExportFunctionOrdinals[j]) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (j &lt; lpExport-&gt;NumberOfNames) &#123;</span><br><span class="line">printf(&quot;\n以函数名称导出: \n\t名称: %s\n\t地址: 0x%x\n\t序号: 0x%x\n&quot;, lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpExportFunctionNames[j]</span><br><span class="line">),</span><br><span class="line">lpExportFunctions[i],</span><br><span class="line">lpExportFunctionOrdinals[j] + lpExport-&gt;Base</span><br><span class="line">);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">printf(&quot;\n以序号导出: \n\t地址: 0x%x\n\t序号: 0x%x\n&quot;, lpExportFunctions[i], i + lpExport-&gt;Base);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">if (hFile) &#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line">if (lpBuffer) &#123;</span><br><span class="line">VirtualFree(lpBuffer, 0, MEM_RELEASE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h4><p>导入表也是比较复杂的, 需要理解导入方式</p><h5 id="相关结构体信息"><a href="#相关结构体信息" class="headerlink" title="相关结构体信息"></a>相关结构体信息</h5><h6 id="导入表-1"><a href="#导入表-1" class="headerlink" title="导入表"></a>导入表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line">typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><h6 id="名称表"><a href="#名称表" class="headerlink" title="名称表"></a>名称表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[1];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><h6 id="导入名称表与导入地址表"><a href="#导入名称表与导入地址表" class="headerlink" title="导入名称表与导入地址表"></a>导入名称表与导入地址表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_THUNK_DATA32 &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD ForwarderString;      // PBYTE </span><br><span class="line">        DWORD Function;             // PDWORD</span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><h6 id="重要字段说明-6"><a href="#重要字段说明-6" class="headerlink" title="重要字段说明"></a>重要字段说明</h6><ul><li><p><strong>导入表</strong></p><ol><li><strong>DUMMYUNIONNAME</strong>:<br> 指向导入名称表的偏移<code>(RVA)</code></li><li><strong>Name</strong>:<br> 导入动态库的名称</li><li><strong>FirstThunk</strong>:<br> 指向导入地址表的偏移<code>(RVA)</code>, 导入地址表在文件中是和导入名称表一样的, 但加载到内存后是不一样的</li></ol></li><li><p><strong>导入名称表与导入地址表</strong></p><ol><li><strong>u1</strong>:<br> 指向的是函数名称的偏移或者序号,<br> 如果是函数明显那么最高位为<code>0</code>否则为序号<br> <em>序号 = ul.Ordinal &amp; ~(0b1 &lt;&lt; 31)</em></li></ol></li><li><p><strong>名称表</strong></p><ol><li><strong>Name</strong><br> 函数名称</li></ol></li></ul><h5 id="打印32位导入表列子"><a href="#打印32位导入表列子" class="headerlink" title="打印32位导入表列子"></a>打印<code>32位</code>导入表列子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD RvaToFov(PIMAGE_SECTION_HEADER sec, DWORD secCount, DWORD rva) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; secCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">if (sec-&gt;VirtualAddress &lt;= rva &amp;&amp; sec-&gt;VirtualAddress + sec-&gt;SizeOfRawData &gt;= rva) &#123;</span><br><span class="line">return rva - sec-&gt;VirtualAddress + sec-&gt;PointerToRawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sec++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void printImportTable(const char* peFileName) &#123;</span><br><span class="line">DWORD fileSize = 0, readSize = 0, secCount = 0;</span><br><span class="line">LPBYTE lpBuffer = NULL;</span><br><span class="line">HANDLE hFile = NULL;</span><br><span class="line">PIMAGE_DOS_HEADER lpDosHeader = NULL; // dos头</span><br><span class="line">PIMAGE_NT_HEADERS32 lpNtHeader = NULL; // nt头</span><br><span class="line">PIMAGE_SECTION_HEADER lpFirstSection = NULL; // 节表</span><br><span class="line"></span><br><span class="line">PIMAGE_THUNK_DATA32 </span><br><span class="line">lpIntHeader = NULL, // 导入名称表 </span><br><span class="line">lpIatHeader = NULL; // 导入地址表</span><br><span class="line"></span><br><span class="line">PIMAGE_IMPORT_BY_NAME lpImportName = NULL;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR lpImport = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hFile = CreateFileA(peFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line"></span><br><span class="line">if (!hFile) &#123;</span><br><span class="line">printf(&quot;读取%s失败\n&quot;, peFileName);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileSize = GetFileSize(hFile, NULL);</span><br><span class="line"></span><br><span class="line">lpBuffer = (LPBYTE)VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">if (!lpBuffer) &#123;</span><br><span class="line">printf(&quot;分配内存失败 %d\n&quot;, fileSize);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!ReadFile(hFile, lpBuffer, fileSize, &amp;readSize, NULL)) &#123;</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpDosHeader = (PIMAGE_DOS_HEADER)lpBuffer;</span><br><span class="line"></span><br><span class="line">if (lpDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">printf(&quot;不是一个有效的PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpNtHeader = (PIMAGE_NT_HEADERS32)(lpBuffer + lpDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (lpNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">printf(&quot;不是一个有效的PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (lpNtHeader-&gt;OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">printf(&quot;不是一个32位PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secCount = lpNtHeader-&gt;FileHeader.NumberOfSections;</span><br><span class="line">lpFirstSection = (PIMAGE_SECTION_HEADER)((LPBYTE)&amp;lpNtHeader-&gt;OptionalHeader + lpNtHeader-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lpImport = (PIMAGE_IMPORT_DESCRIPTOR)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection, </span><br><span class="line">secCount, </span><br><span class="line">lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">while (lpImport-&gt;Name != 0) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;\n 导入动态库名称: %s\n&quot;, (lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpImport-&gt;Name</span><br><span class="line">)));</span><br><span class="line"></span><br><span class="line">lpIntHeader = (PIMAGE_THUNK_DATA32)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpImport-&gt;OriginalFirstThunk</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">lpIatHeader = (PIMAGE_THUNK_DATA32)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpImport-&gt;FirstThunk</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">while (lpIntHeader-&gt;u1.Function != 0) &#123;</span><br><span class="line"></span><br><span class="line">if (lpIatHeader-&gt;u1.Function &gt;&gt; 31 == 1) &#123;</span><br><span class="line">printf(&quot;\t序号导入: 0x%x\n&quot;, lpIatHeader-&gt;u1.Ordinal &amp; ~(0b1 &lt;&lt; 31));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">lpImportName = (PIMAGE_IMPORT_BY_NAME)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpIatHeader-&gt;u1.Function</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">printf(&quot;\t名称导入: %s\n&quot;, lpImportName-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpIntHeader++;</span><br><span class="line">lpIatHeader++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpImport++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line"></span><br><span class="line">if (hFile) &#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (lpBuffer) &#123;</span><br><span class="line">VirtualFree(lpBuffer, 0, MEM_RELEASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><h5 id="结构体信息-7"><a href="#结构体信息-7" class="headerlink" title="结构体信息"></a>结构体信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_BASE_RELOCATION &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line">//  WORD    TypeOffset[1];</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line">typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><h5 id="重要字段说明-7"><a href="#重要字段说明-7" class="headerlink" title="重要字段说明"></a>重要字段说明</h5><ol><li><strong>VirtualAddress</strong>:<br> 偏移基址</li><li><strong>SizeOfBlock</strong>:<br> 当前表大小</li></ol><h5 id="打印32位重定位表列子"><a href="#打印32位重定位表列子" class="headerlink" title="打印32位重定位表列子"></a>打印<code>32位</code>重定位表列子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD RvaToFov(PIMAGE_SECTION_HEADER sec, DWORD secCount, DWORD rva) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; secCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">if (sec-&gt;VirtualAddress &lt;= rva &amp;&amp; sec-&gt;VirtualAddress + sec-&gt;SizeOfRawData &gt;= rva) &#123;</span><br><span class="line">return rva - sec-&gt;VirtualAddress + sec-&gt;PointerToRawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sec++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printRelocTable(const char* peFileName) &#123;</span><br><span class="line">DWORD fileSize = 0, readSize = 0, secCount = 0;</span><br><span class="line">LPBYTE lpBuffer = NULL;</span><br><span class="line">HANDLE hFile = NULL;</span><br><span class="line">LPWORD lpRelocAddress = NULL;</span><br><span class="line">PIMAGE_DOS_HEADER lpDosHeader = NULL; // dos头</span><br><span class="line">PIMAGE_NT_HEADERS32 lpNtHeader = NULL; // nt头</span><br><span class="line">PIMAGE_SECTION_HEADER lpFirstSection = NULL; // 节表</span><br><span class="line">PIMAGE_BASE_RELOCATION lpRelocHeader = NULL;</span><br><span class="line"></span><br><span class="line">hFile = CreateFileA(peFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line"></span><br><span class="line">if (!hFile) &#123;</span><br><span class="line">printf(&quot;读取%s失败\n&quot;, peFileName);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileSize = GetFileSize(hFile, NULL);</span><br><span class="line"></span><br><span class="line">lpBuffer = (LPBYTE)VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">if (!lpBuffer) &#123;</span><br><span class="line">printf(&quot;分配内存失败 %d\n&quot;, fileSize);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!ReadFile(hFile, lpBuffer, fileSize, &amp;readSize, NULL)) &#123;</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpDosHeader = (PIMAGE_DOS_HEADER)lpBuffer;</span><br><span class="line"></span><br><span class="line">if (lpDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">printf(&quot;不是一个有效的PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpNtHeader = (PIMAGE_NT_HEADERS32)(lpBuffer + lpDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (lpNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">printf(&quot;不是一个有效的PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (lpNtHeader-&gt;OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">printf(&quot;不是一个32位PE文件\n&quot;);</span><br><span class="line">goto exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secCount = lpNtHeader-&gt;FileHeader.NumberOfSections;</span><br><span class="line">lpFirstSection = (PIMAGE_SECTION_HEADER)((LPBYTE)&amp;lpNtHeader-&gt;OptionalHeader + lpNtHeader-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line">lpRelocHeader = (PIMAGE_BASE_RELOCATION)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">while (lpRelocHeader-&gt;SizeOfBlock != 0) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;\n重定位修复: &quot;);</span><br><span class="line">printf(&quot;\n\t基址(RVA): 0x%x&quot;, lpRelocHeader-&gt;VirtualAddress);</span><br><span class="line">printf(&quot;\n\t块儿大小: 0x%x&quot;, lpRelocHeader-&gt;SizeOfBlock);</span><br><span class="line">printf(&quot;\n\t需要重定位数量: 0x%x&quot;, (lpRelocHeader-&gt;SizeOfBlock - 8) / 2);</span><br><span class="line"></span><br><span class="line">lpRelocAddress = (LPWORD)((LPBYTE)lpRelocHeader + 8);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; (lpRelocHeader-&gt;SizeOfBlock - 8) / 2; i++) &#123;</span><br><span class="line"></span><br><span class="line">if (lpRelocAddress[i] &gt;&gt; 12 == 3) &#123;</span><br><span class="line">DWORD addrOffset = lpRelocAddress[i] &amp; 0xFFF;</span><br><span class="line">DWORD addrValue = *((DWORD *)(lpBuffer + RvaToFov(</span><br><span class="line">lpFirstSection,</span><br><span class="line">secCount,</span><br><span class="line">addrOffset + lpRelocHeader-&gt;VirtualAddress</span><br><span class="line">)));</span><br><span class="line"></span><br><span class="line">printf(&quot;\n\t地址(RVA): 0x%x&quot;,  addrOffset + lpRelocHeader-&gt;VirtualAddress);</span><br><span class="line">printf(&quot;\n\t当前值: 0x%x&quot;, addrValue);</span><br><span class="line">printf(&quot;\n\t偏移: 0x%x\n&quot;, addrValue - lpNtHeader-&gt;OptionalHeader.ImageBase);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpRelocHeader = (PIMAGE_BASE_RELOCATION)((LPBYTE)lpRelocHeader + lpRelocHeader-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line"></span><br><span class="line">if (hFile) &#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (lpBuffer) &#123;</span><br><span class="line">VirtualFree(lpBuffer, 0, MEM_RELEASE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可移植可执行&quot;&gt;&lt;a href=&quot;#可移植可执行&quot; class=&quot;headerlink&quot; title=&quot;可移植可执行&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E</summary>
      
    
    
    
    <category term="Windows" scheme="http://editso.github.io/categories/Windows/"/>
    
    <category term="PE" scheme="http://editso.github.io/categories/Windows/PE/"/>
    
    
    <category term="Windows" scheme="http://editso.github.io/tags/Windows/"/>
    
    <category term="PE" scheme="http://editso.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>记一次C内存溢出问题</title>
    <link href="http://editso.github.io/wiki/c-01-log/"/>
    <id>http://editso.github.io/wiki/c-01-log/</id>
    <published>2021-03-21T01:30:49.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次C内存溢出问题"><a href="#记一次C内存溢出问题" class="headerlink" title="记一次C内存溢出问题"></a>记一次<code>C</code>内存溢出问题</h1><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void func()&#123;</span><br><span class="line">        char buff[1024 * 1024 * 10];</span><br><span class="line">        printf(&quot;hello func\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">        func();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译后运行直接段错误,查了半天硬是没查出问题, 后突然想到是不是栈空间满了,查了下百度果不其然<br>在我的Linux下使用<code>ulimit -s</code>查出我的系统栈空间大小为<code>8kb</code>而我开辟了<code>1MB</code>的空间所以出现段错误</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>将 <code>buff</code>变量加上<code>static</code>关键字或缩小<code>buff</code>大小即可解决问题,还可以将<code>buff</code>作为全局变量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记一次C内存溢出问题&quot;&gt;&lt;a href=&quot;#记一次C内存溢出问题&quot; class=&quot;headerlink&quot; title=&quot;记一次C内存溢出问题&quot;&gt;&lt;/a&gt;记一次&lt;code&gt;C&lt;/code&gt;内存溢出问题&lt;/h1&gt;&lt;h2 id=&quot;问题代码&quot;&gt;&lt;a href=&quot;#问题代码</summary>
      
    
    
    
    <category term="问题记录" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C相关" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="C" scheme="http://editso.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="GCC" scheme="http://editso.github.io/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>GRUB双系统找不到Windows问题</title>
    <link href="http://editso.github.io/wiki/grub-log/"/>
    <id>http://editso.github.io/wiki/grub-log/</id>
    <published>2021-03-21T00:55:37.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GRUB双系统找不到Windows问题"><a href="#GRUB双系统找不到Windows问题" class="headerlink" title="GRUB双系统找不到Windows问题"></a><code>GRUB</code>双系统找不到<code>Windows</code>问题</h1><p>问题截图<br><img src="/images/grub/01.png" alt="GRUB"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>1.编辑: <code>/etc/default/grub</code><br>2.添加: <code>GRUB_DISABLE_OS_PROBER=false</code><br>3.执行: <code>sudo update-grub</code><br><img src="/images/grub/02.png" alt="GRUB"></p><p>参考: <a href="https://dreamanddead.github.io/post/grub-find-win-back/">记一次 Grub 找回 Win10 启动项的过程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GRUB双系统找不到Windows问题&quot;&gt;&lt;a href=&quot;#GRUB双系统找不到Windows问题&quot; class=&quot;headerlink&quot; title=&quot;GRUB双系统找不到Windows问题&quot;&gt;&lt;/a&gt;&lt;code&gt;GRUB&lt;/code&gt;双系统找不到&lt;code&gt;</summary>
      
    
    
    
    <category term="问题记录" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Grub" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Grub/"/>
    
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="GRUB" scheme="http://editso.github.io/tags/GRUB/"/>
    
    <category term="Manjaro" scheme="http://editso.github.io/tags/Manjaro/"/>
    
    <category term="Windows" scheme="http://editso.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>acm-士兵队列训练问题</title>
    <link href="http://editso.github.io/wiki/acm-01/"/>
    <id>http://editso.github.io/wiki/acm-01/</id>
    <published>2020-11-08T15:44:38.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="士兵队列训练问题"><a href="#士兵队列训练问题" class="headerlink" title="士兵队列训练问题"></a>士兵队列训练问题</h1><p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。 </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该题意思是,队列编号第一轮编号<code>1~2</code>叫到 <code>2</code> 的出列, 第二轮编号<code>1~3</code>叫到<code>3</code>的出列,反复循环直到剩余人数不超过<code>3</code>人</p><h2 id="实现代码-c"><a href="#实现代码-c" class="headerlink" title="实现代码 c"></a>实现代码 <code>c</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void full(int num, int *soldier)&#123;</span><br><span class="line">    for (int i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        soldier[i] = i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int* line_up(int num)&#123;</span><br><span class="line">    int* soldier = malloc(sizeof(int) * num);</span><br><span class="line">    //初始化士兵</span><br><span class="line">    full(num, soldier);</span><br><span class="line">    /**</span><br><span class="line">     * i: 当前士兵</span><br><span class="line">     * j: 报数</span><br><span class="line">     * s: 最高编号</span><br><span class="line">    */</span><br><span class="line">    for (int i = 0, j = 1, s = 2, m = num; m &gt;= 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i &gt; num &amp;&amp; s == 2)&#123;</span><br><span class="line">            /**</span><br><span class="line">             * 第一轮报数完成, 进行第二轮报数</span><br><span class="line">            */</span><br><span class="line">            s = 3; i = 0; j = 1;</span><br><span class="line">        &#125;else if(i &gt; num &amp;&amp; s == 3)&#123;</span><br><span class="line">            /**</span><br><span class="line">             * 第二轮报数完成,重新开始到第一轮报数</span><br><span class="line">            */</span><br><span class="line">            s = 2,  i = 0, j = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 当前士兵已经出列, 继续报数</span><br><span class="line">        */</span><br><span class="line">        if(soldier[i] == -1) continue;</span><br><span class="line">        if(j == s)&#123;</span><br><span class="line">            /**</span><br><span class="line">             * 出列</span><br><span class="line">            */</span><br><span class="line">            soldier[i] = -1;</span><br><span class="line">            j = 1; m--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            j++; // 编号</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return soldier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int out_soldier(int num)&#123;</span><br><span class="line">    int *soldier = line_up(num);</span><br><span class="line">    for (int i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        if(soldier[i] == -1) continue;</span><br><span class="line">        printf(&quot;%d &quot;, soldier[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    free(soldier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int row, col;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;row);</span><br><span class="line">    int array[row], i = 0;</span><br><span class="line">    while (i &lt; row)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, array + i++);</span><br><span class="line">    &#125;</span><br><span class="line">    i = 0;</span><br><span class="line">    while (i &lt; row)</span><br><span class="line">    &#123;</span><br><span class="line">        out_soldier(array[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;士兵队列训练问题&quot;&gt;&lt;a href=&quot;#士兵队列训练问题&quot; class=&quot;headerlink&quot; title=&quot;士兵队列训练问题&quot;&gt;&lt;/a&gt;士兵队列训练问题&lt;/h1&gt;&lt;p&gt;某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开</summary>
      
    
    
    
    <category term="算法学习" scheme="http://editso.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Algorithm" scheme="http://editso.github.io/tags/Algorithm/"/>
    
    <category term="Acm" scheme="http://editso.github.io/tags/Acm/"/>
    
    <category term="C" scheme="http://editso.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>记录一次学习C++时编译失败出现(multiple definition of xxx first defined here collect2)</title>
    <link href="http://editso.github.io/wiki/c-log/"/>
    <id>http://editso.github.io/wiki/c-log/</id>
    <published>2020-11-03T23:49:32.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录一次学习C-时编译失败出现-multiple-definition-of-xxx-first-defined-here-collect2"><a href="#记录一次学习C-时编译失败出现-multiple-definition-of-xxx-first-defined-here-collect2" class="headerlink" title="记录一次学习C++时编译失败出现(multiple definition of xxx first defined here collect2)"></a>记录一次学习C++时编译失败出现(multiple definition of xxx first defined here collect2)</h1><p><img src="/images/cplusplus/log.png" alt="log"><br>报错说我重复定义了这个重载函数, 网上查了半天,说是头文件没有写<code>#ifndef &amp; #define</code>可是我明明写了, 还是不起作用,又说使用关键字<code>extern</code>, 可是我就是要定义在头文件里面,后来看了<code>c++</code>的全局重载函数,发现都写了<code>inline</code>修饰,于是试了试结果成功了</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用<code>inline</code>修饰这个函数,使用它修饰需要考虑自己的代码是否符合<code>inline</code></p><h2 id="inline相关"><a href="#inline相关" class="headerlink" title="inline相关"></a><code>inline</code>相关</h2><p>在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。  </p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>我理解它其实就是和宏定义差不多,宏定义会在编译器编译时进行宏展开,而<code>inline</code>做的事情其实和它是差不多的,只不过<code>inline</code>会有一些使用限制.<br>然后我这个错误在还未链接时是没有错误的,在链接是就出现了重复定义,使用<code>inline</code>就正好解决了我遇到的问题,因为它在编译时就会把这个函数转换为内联函数,所以在链接时就不会出现重复定义问题</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.runoob.com/w3cnote/cpp-inline-usage.html">C++ 中的 inline 用法</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记录一次学习C-时编译失败出现-multiple-definition-of-xxx-first-defined-here-collect2&quot;&gt;&lt;a href=&quot;#记录一次学习C-时编译失败出现-multiple-definition-of-xxx-first-d</summary>
      
    
    
    
    <category term="问题记录" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C相关" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="CPP" scheme="http://editso.github.io/tags/CPP/"/>
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>解决VirtualBox无法启用嵌套分页</title>
    <link href="http://editso.github.io/wiki/virtualbox-log/"/>
    <id>http://editso.github.io/wiki/virtualbox-log/</id>
    <published>2020-10-30T23:19:26.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VirtualBox-无法启用嵌套分页"><a href="#VirtualBox-无法启用嵌套分页" class="headerlink" title="VirtualBox 无法启用嵌套分页"></a><code>VirtualBox</code> 无法启用嵌套分页</h1><p><img src="/public/images/virtualbox/nested.png" alt="问题截图"></p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>开启嵌套分页:</p><p><strong><code>VBoxManage modifyvm &quot;虚拟机名字&quot; --nested-hw-virt on</code></strong>  </p><p><img src="/public/images/virtualbox/nested-fixs.png" alt="修复"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VirtualBox-无法启用嵌套分页&quot;&gt;&lt;a href=&quot;#VirtualBox-无法启用嵌套分页&quot; class=&quot;headerlink&quot; title=&quot;VirtualBox 无法启用嵌套分页&quot;&gt;&lt;/a&gt;&lt;code&gt;VirtualBox&lt;/code&gt; 无法启用嵌</summary>
      
    
    
    
    <category term="软件相关" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    
    <category term="VirtualBox" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/VirtualBox/"/>
    
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="VirtualBox" scheme="http://editso.github.io/tags/VirtualBox/"/>
    
  </entry>
  
  <entry>
    <title>记录一次Manjaro下VirtualBox界面文字不显示,黑屏</title>
    <link href="http://editso.github.io/wiki/virtualbox-manjaro-log/"/>
    <id>http://editso.github.io/wiki/virtualbox-manjaro-log/</id>
    <published>2020-10-29T23:36:16.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题截图"><a href="#问题截图" class="headerlink" title="问题截图"></a>问题截图</h2><p><img src="/images/virtualbox/log.png" alt="文字不显示"></p><h2 id="我的解决办法"><a href="#我的解决办法" class="headerlink" title="我的解决办法"></a>我的解决办法</h2><p>尝试了各种办法,在网上查了半天资料都没有解决这个问题,后来我去设置把外观都重置了问题得以解决,后来我通过排除的方式发现是  <strong><code>颜色</code></strong> 的问题,修改 <strong><code>颜色</code></strong> 后问题解决</p><p><strong>位置: <code>系统设置 &gt; 外观 &gt; 颜色</code></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题截图&quot;&gt;&lt;a href=&quot;#问题截图&quot; class=&quot;headerlink&quot; title=&quot;问题截图&quot;&gt;&lt;/a&gt;问题截图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/virtualbox/log.png&quot; alt=&quot;文字不显示&quot;&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="Linux" scheme="http://editso.github.io/categories/Linux/"/>
    
    <category term="Manjaro" scheme="http://editso.github.io/categories/Linux/Manjaro/"/>
    
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="VirtualBox" scheme="http://editso.github.io/tags/VirtualBox/"/>
    
    <category term="Kde" scheme="http://editso.github.io/tags/Kde/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro系统的使用</title>
    <link href="http://editso.github.io/wiki/manjaro-use/"/>
    <id>http://editso.github.io/wiki/manjaro-use/</id>
    <published>2020-10-28T10:41:21.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍:"></a>简单介绍:</h1><h2 id="Manjaro是一款基于Arch-Linux、对用户友好、全球排名非常靠前的Linux发行版"><a href="#Manjaro是一款基于Arch-Linux、对用户友好、全球排名非常靠前的Linux发行版" class="headerlink" title="Manjaro是一款基于Arch Linux、对用户友好、全球排名非常靠前的Linux发行版"></a>Manjaro是一款基于Arch Linux、对用户友好、全球排名非常靠前的Linux发行版</h2><p>来源:<a href="https://linux265.com/distro.php?id=26">Linux265</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍:&quot;&gt;&lt;/a&gt;简单介绍:&lt;/h1&gt;&lt;h2 id=&quot;Manjaro是一款基于Arch-Linux、对用户友好、全球排名非常靠前的Linux发行版&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Linux" scheme="http://editso.github.io/categories/Linux/"/>
    
    <category term="Manjaro" scheme="http://editso.github.io/categories/Linux/Manjaro/"/>
    
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="系统" scheme="http://editso.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="开源" scheme="http://editso.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>记录一次Flutter run时出现的错误</title>
    <link href="http://editso.github.io/wiki/flutter-log/"/>
    <id>http://editso.github.io/wiki/flutter-log/</id>
    <published>2020-05-20T22:05:29.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Flutter-run-出现错误"><a href="#使用Flutter-run-出现错误" class="headerlink" title="使用Flutter run 出现错误:"></a>使用Flutter run 出现错误:</h2><p><img src="/images/flutter-run.png"></p><h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因:"></a>错误原因:</h2><p>镜像：<code>https://storage.googleapis.com/download.flutter.io</code> 访问不了</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>更改仓库地址为 <code>https://storage.flutter-io.cn/download.flutter.io</code></p><pre><code>allprojects &#123;    repositories &#123;        google()        jcenter()        maven &#123;url &quot;https://storage.flutter-io.cn/download.flutter.io&quot;&#125;    &#125;&#125;```</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用Flutter-run-出现错误&quot;&gt;&lt;a href=&quot;#使用Flutter-run-出现错误&quot; class=&quot;headerlink&quot; title=&quot;使用Flutter run 出现错误:&quot;&gt;&lt;/a&gt;使用Flutter run 出现错误:&lt;/h2&gt;&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="问题记录" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Flutter" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Flutter/"/>
    
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="踩坑" scheme="http://editso.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="Flutter" scheme="http://editso.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>桌面壁纸网站</title>
    <link href="http://editso.github.io/wiki/wallpaper/"/>
    <id>http://editso.github.io/wiki/wallpaper/</id>
    <published>2019-12-28T13:55:00.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桌面壁纸网站"><a href="#桌面壁纸网站" class="headerlink" title="桌面壁纸网站"></a>桌面壁纸网站</h1><ol><li><a href="https://wallpapershome.com/">wallpapershome</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;桌面壁纸网站&quot;&gt;&lt;a href=&quot;#桌面壁纸网站&quot; class=&quot;headerlink&quot; title=&quot;桌面壁纸网站&quot;&gt;&lt;/a&gt;桌面壁纸网站&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://wallpapershome.com/&quot;&gt;wallpapers</summary>
      
    
    
    
    <category term="杂项" scheme="http://editso.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Theme" scheme="http://editso.github.io/tags/Theme/"/>
    
    <category term="壁纸" scheme="http://editso.github.io/tags/%E5%A3%81%E7%BA%B8/"/>
    
    <category term="Desktop" scheme="http://editso.github.io/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu使用</title>
    <link href="http://editso.github.io/wiki/ubuntu-theme/"/>
    <id>http://editso.github.io/wiki/ubuntu-theme/</id>
    <published>2019-12-24T17:05:21.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu使用"><a href="#Ubuntu使用" class="headerlink" title="Ubuntu使用"></a>Ubuntu使用</h1><h3 id="切换阿里云软件源"><a href="#切换阿里云软件源" class="headerlink" title="切换阿里云软件源:"></a>切换阿里云软件源:</h3><p>编辑： <code>sudo vim /etc/apt/sources.list</code>  </p><ul><li>将默认的：<a href="http://archive.ubuntu.com/">http://archive.ubuntu.com/</a></li><li>替换为： <a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com</a></li></ul><blockquote><p>配置如下:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>参考 <a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.53322f70EzruKZ">Ubuntu 镜像</a></p><h3 id="谷歌拼音输入法"><a href="#谷歌拼音输入法" class="headerlink" title="谷歌拼音输入法:"></a>谷歌拼音输入法:</h3><blockquote><p><code>sudo apt install fcitx fcitx-googlepinyin</code>    </p></blockquote><p>设置输入法:<br><code>设置&gt;区域与语言&gt;管理已安装的语言&gt;键盘输入法系统&gt;fcitx</code><br>注销电脑配置重新登录, 在应用程序中找到<code>fcitx配置</code>或搜索配置谷歌输入法 </p><h3 id="主题美化工具"><a href="#主题美化工具" class="headerlink" title="主题美化工具"></a>主题美化工具</h3><p>安装：<code>sudo apt install gnome-tweak-tool gnome-shell-extensions</code><br>shell: <a href="https://www.gnome-look.org/p/1333760/">ChromeOS shell theme</a><br>鼠标指针: <a href="https://www.gnome-look.org/p/1197198/">Bibata</a><br>dock栏： <a href="https://extensions.gnome.org/extension/307/dash-to-dock/">dash-to-dock</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu使用&quot;&gt;&lt;a href=&quot;#Ubuntu使用&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu使用&quot;&gt;&lt;/a&gt;Ubuntu使用&lt;/h1&gt;&lt;h3 id=&quot;切换阿里云软件源&quot;&gt;&lt;a href=&quot;#切换阿里云软件源&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux" scheme="http://editso.github.io/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="http://editso.github.io/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="Theme" scheme="http://editso.github.io/tags/Theme/"/>
    
    <category term="Ubuntu" scheme="http://editso.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>记录一次使用vue-cli4.0 创建项目时非常慢问题</title>
    <link href="http://editso.github.io/wiki/vue-log/"/>
    <id>http://editso.github.io/wiki/vue-log/</id>
    <published>2019-12-19T11:07:51.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录一次使用vue-cli4-0-创建项目时非常慢问题"><a href="#记录一次使用vue-cli4-0-创建项目时非常慢问题" class="headerlink" title="记录一次使用vue-cli4.0 创建项目时非常慢问题"></a>记录一次使用vue-cli4.0 创建项目时非常慢问题</h1><p>使用<code>vue</code>时在创建项目遇到创建项目非常慢<br>然后各种办法都不行, 最后问了我朋友,朋友告诉我是我的<code>npm node vue</code>版本过低<br>当时想只需要更新<code>npm vue</code>版本就行后还是下载很慢,最后将<code>node</code>更新故问题解决</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤:"></a>解决步骤:</h3><ul><li>更新 <code>npm</code>: <code>npm install npm@latest -g</code>  </li><li>安装 <code>n</code>: <code>npm install -g n --force</code></li><li>更新 <code>node</code>: <code>sudo n stable</code></li><li>下载最新 <code>vue</code>: <code>sudo npm install -g @vue/cli</code><br>更新好后重启终端问题解决!  </li></ul><h3 id="命令整合"><a href="#命令整合" class="headerlink" title="命令整合:"></a>命令整合:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install npm@latest -g  </span><br><span class="line">npm install -g n --force  </span><br><span class="line">sudo n stable </span><br><span class="line">sudo npm install -g @vue/cli </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记录一次使用vue-cli4-0-创建项目时非常慢问题&quot;&gt;&lt;a href=&quot;#记录一次使用vue-cli4-0-创建项目时非常慢问题&quot; class=&quot;headerlink&quot; title=&quot;记录一次使用vue-cli4.0 创建项目时非常慢问题&quot;&gt;&lt;/a&gt;记录一次使</summary>
      
    
    
    
    <category term="问题记录" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="前端相关" scheme="http://editso.github.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="踩坑记" scheme="http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql8.0踩坑</title>
    <link href="http://editso.github.io/wiki/mysql-log/"/>
    <id>http://editso.github.io/wiki/mysql-log/</id>
    <published>2019-12-19T10:53:06.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql8-0采坑"><a href="#Mysql8-0采坑" class="headerlink" title="Mysql8.0采坑"></a>Mysql8.0采坑</h1><h2 id="密码无法使用"><a href="#密码无法使用" class="headerlink" title="密码无法使用"></a>密码无法使用</h2><p>在服务器中安装<code>mysql8.0</code>数据库修改密码发现无法使用<code>update</code>语句修改,于是百度了一番参考了<a href="https://blog.csdn.net/yi247630676/article/details/80352655">MYSQL8.0以上版本正确修改ROOT密码</a>由此问题解决  </p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h3><ol><li>使用<code>mysql</code>初始生成的密码登录到数据库(密码在数据库产生的日志文件中, 可查看/<code>etc/my.cnf</code>中的<code>log-error</code>指向的文件)  </li><li>登录到数据库 <code>mysql -uroot -p&#39;首次初始化数据库产生的密码&#39;</code>  </li><li>登录执行 <code>alter user &#39;root&#39;@localhost identified by &#39;new password&#39;;</code> </li><li>执行成功后刷新数据库 <code>flush privileges;</code>问题成功解决  </li></ol><h2 id="连接出现-cryptography-is-required-for-sha256-password-or-caching-sha2-password"><a href="#连接出现-cryptography-is-required-for-sha256-password-or-caching-sha2-password" class="headerlink" title="连接出现 cryptography is required for sha256_password or caching_sha2_password**"></a>连接出现 <code>cryptography is required for sha256_password or caching_sha2_password</code>**</h2><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法:"></a>解决方法:</h3><ol><li><p>首先查询一下数据库<code>user</code>表中<code>连接时报错的用户与主机</code>  </p><pre><code> mysql&gt; select user,plugin,host  from mysql.user;  +------------------+-----------------------+-----------+   | user             | plugin                | host      |   +------------------+-----------------------+-----------+   | root             | mysql_native_password | %         |   | mysql.infoschema | caching_sha2_password | localhost |   | mysql.session    | caching_sha2_password | localhost |   | mysql.sys        | caching_sha2_password | localhost |   | root             | mysql_native_password | localhost |   +------------------+-----------------------+-----------+   5 rows in set (0.00 sec)  </code></pre></li><li><p><code>%</code> 表示通配符</p></li><li><p>查询得出 <code>plugin </code>为 <code>caching_sha2_password</code> 就将它改为 <code>mysql_native_password</code>执行如下命令:<br>  <code>alter user &#39;your account&#39;@&#39;your host&#39; identified with mysql_native_password by &#39;your password&#39;</code></p></li><li><p><code>flush privileges</code> #刷新权限</p></li><li><p>重新连接， 问题解决 。参考了<code>msql8.0</code>官方文档<a href="https://dev.mysql.com/doc/refman/8.0/en/pluggable-authentication.html">可插拔身份验证</a></p></li></ol><h3 id="不成功其他解决方法"><a href="#不成功其他解决方法" class="headerlink" title="不成功其他解决方法"></a>不成功其他解决方法</h3><ol><li>参考 <a href="https://blog.csdn.net/p_xiaobai/article/details/85334875">mysql报错RuntimeError: cryptography is required for sha256_password or caching_sha2_p</a></li><li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;</code> #修改加密规则  </li><li><code> ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</code> #更新一下用户的密码 </li><li><code>FLUSH PRIVILEGES;</code> #刷新权限</li><li><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code>  # 再次重置密码</li><li>重启服务,问题解决 </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql8-0采坑&quot;&gt;&lt;a href=&quot;#Mysql8-0采坑&quot; class=&quot;headerlink&quot; title=&quot;Mysql8.0采坑&quot;&gt;&lt;/a&gt;Mysql8.0采坑&lt;/h1&gt;&lt;h2 id=&quot;密码无法使用&quot;&gt;&lt;a href=&quot;#密码无法使用&quot; class=&quot;</summary>
      
    
    
    
    <category term="软件相关" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Mysql" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Mysql/"/>
    
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="Mysql" scheme="http://editso.github.io/tags/Mysql/"/>
    
    <category term="踩坑记" scheme="http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
    <category term="数据库" scheme="http://editso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>记录一次服务器免密登录失效问题</title>
    <link href="http://editso.github.io/wiki/ssh-log/"/>
    <id>http://editso.github.io/wiki/ssh-log/</id>
    <published>2019-12-19T10:32:57.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH免密登陆失效"><a href="#SSH免密登陆失效" class="headerlink" title="SSH免密登陆失效"></a>SSH免密登陆失效</h1><p>在本地使用<code>ssh-keygen</code>生成密钥  </p><blockquote><p><code>ssh-keygen -t rsa</code></p></blockquote><p>将本地<code>~/.ssh/id_rsa.pub</code>使用<code>ssh-copy-id</code>复制到<code>user@hostname</code>下  </p><blockquote><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub user@hostname</code></p></blockquote><p>成功后我尝试使用<code>ssh user@hostname</code>连接发现还是需要输入密码</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>服务端<code>~/.ssh</code>文件夹权限必须是 <strong><code>700</code></strong>  </p><blockquote><p><code>chmod 700 ~/.ssh</code>  </p></blockquote><p>服务端<code>~/.ssh/authorized_keys</code>权限必须是 <strong><code>600</code></strong>  </p><blockquote><p><code>chmod 600 ~/.ssh/autohrized_keys</code>  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH免密登陆失效&quot;&gt;&lt;a href=&quot;#SSH免密登陆失效&quot; class=&quot;headerlink&quot; title=&quot;SSH免密登陆失效&quot;&gt;&lt;/a&gt;SSH免密登陆失效&lt;/h1&gt;&lt;p&gt;在本地使用&lt;code&gt;ssh-keygen&lt;/code&gt;生成密钥  &lt;/p&gt;
&lt;bl</summary>
      
    
    
    
    <category term="Linux" scheme="http://editso.github.io/categories/Linux/"/>
    
    <category term="SSH" scheme="http://editso.github.io/categories/Linux/SSH/"/>
    
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="日志" scheme="http://editso.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="踩坑记" scheme="http://editso.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
    <category term="SSH" scheme="http://editso.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>linux系统函数学习</title>
    <link href="http://editso.github.io/wiki/linux-func-use/"/>
    <id>http://editso.github.io/wiki/linux-func-use/</id>
    <published>2019-12-01T18:57:27.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统函数学习"><a href="#Linux系统函数学习" class="headerlink" title="Linux系统函数学习"></a>Linux系统函数学习</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><code>程序</code>: 死的, 只会占用磁盘空间<br><code>进程</code>: 活的,运行起来的程序,占用内存,cpu系统资源等  </p><h2 id="PCB进程控制块"><a href="#PCB进程控制块" class="headerlink" title="PCB进程控制块"></a>PCB进程控制块</h2><p>就是一个结构体</p><blockquote><p>相关信息: </p></blockquote><ul><li> 进程id, 文件描述符, 进程工作目录, *umask掩码, 信号相关信息资源, 用户id和组id,  </li><li>进程状态: 初始态, 就绪态, 运行态, 挂起态, 终止态  </li></ul><h2 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a><code>fork()</code>函数</h2><p>创建子进程, 父进程各自返回.父进程返回子进程<code>pid</code>, 子进程返回<code>0</code><br>头文件:<code>unistd.h</code>  </p><ul><li><p>父子进程相同:<br>刚fork后:  data段, text段, 堆, 栈, 环境变量, 宿主目录位置, 进程工作位置, 信号处理方式  </p></li><li><p>父子进程不同:<br>进程id, 返回值, 各自的父进程, 进程创建时间, 闹钟, 未决信号集  </p></li><li><p>父子进程共享:<br>读时共享,写时复制<br>文件描述符, mmap映射区  </p></li><li><p>获取进程各个<code>id</code>函数:<br><code>getpid()</code>:获取当前进程<code>id</code><br><code>getppid()</code>:获取父进程的<code>id</code><br><code>getgid()</code>:获取当前组<code>id</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux系统函数学习&quot;&gt;&lt;a href=&quot;#Linux系统函数学习&quot; class=&quot;headerlink&quot; title=&quot;Linux系统函数学习&quot;&gt;&lt;/a&gt;Linux系统函数学习&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux" scheme="http://editso.github.io/categories/Linux/"/>
    
    <category term="API" scheme="http://editso.github.io/categories/Linux/API/"/>
    
    
    <category term="C" scheme="http://editso.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://editso.github.io/tags/Linux/"/>
    
    <category term="编程" scheme="http://editso.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>makefile文件的使用</title>
    <link href="http://editso.github.io/wiki/makefile-use/"/>
    <id>http://editso.github.io/wiki/makefile-use/</id>
    <published>2019-11-28T11:01:00.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="makefile文件的使用"><a href="#makefile文件的使用" class="headerlink" title="makefile文件的使用"></a>makefile文件的使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>makefile</code>是一个脚本文件，将命令整合到一起来执行，提高开发效率<br>使用它脚本名如果不指定<code>-f</code>参数那么脚本文件命名必须要使用 <em><code>makefile</code> or <code>Makefile</code></em></p><h2 id="一个规则"><a href="#一个规则" class="headerlink" title="一个规则"></a>一个规则</h2><p>生成目标:生成目标对应的依赖<br>++++执行语句<br><em>注意:生成语句必须是换行后缩进<code>4</code>个空格</em></p><h2 id="两个函数"><a href="#两个函数" class="headerlink" title="两个函数*"></a>两个函数*</h2><p>函数调用方法:<code>$(函数名 args1, args2)</code><br><code>$(wildcard pattern)</code>:获取所有匹配的内容，返回一个列表<br><code>$(patsubst %, %,  p3)</code>:获取某个列表中的所有值,并将参数1匹配到替换为参数二</p><h2 id="三个变量"><a href="#三个变量" class="headerlink" title="三个变量"></a>三个变量</h2><p><code>$^</code>:获取一个规则中所有的依赖<br><code>$@</code>:获取一个规则中生成的目标<br><code>$&lt;</code>:获取一个规则中第一个依赖,它还有一个特性就是在使用规则匹配时有多个依赖可以将他们都拆分开  </p><h2 id="静态-规则匹配"><a href="#静态-规则匹配" class="headerlink" title="[静态]规则匹配"></a>[静态]规则匹配</h2><p><code>%:%</code>:匹配任意的规则<br>如: <code>%.c:%.o</code>表示匹配目标后缀为<code>.c</code>的以应依赖为<code>.o</code>的<br><code>$(目标依赖文件)</code> or <code>t1,12....:%:%</code>:在执行规则时,在执行到目标依赖文件时才会执行到该语句<br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 规则</span><br><span class="line">src = $(wildcard *.c)</span><br><span class="line">obj = $(patsubst %.c, %.o, $(src))</span><br><span class="line">a.out:$(obj)</span><br><span class="line">    gcc $(obj) -o $@</span><br><span class="line"></span><br><span class="line">$(obj):%.o:%c</span><br><span class="line">    gcc $&lt; -0 $@</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>all</code>:表示执行的最终目标<br>不是用它默认是第一条就是最终目标<br><code>clean</code>:执行清理语句在执行的时候使用<code>make clean -n</code>来显示出要被清理文件执行直接去掉<code>-n</code><br><code>make -f</code>:表示指定要执行的<code>makefile</code>, 如果指定了它要执行<code>clean</code>就需要用<code>make -f 指定的makefile clean</code> 来执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;makefile文件的使用&quot;&gt;&lt;a href=&quot;#makefile文件的使用&quot; class=&quot;headerlink&quot; title=&quot;makefile文件的使用&quot;&gt;&lt;/a&gt;makefile文件的使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cla</summary>
      
    
    
    
    <category term="软件相关" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Make" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Make/"/>
    
    
    <category term="Make" scheme="http://editso.github.io/tags/Make/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试工具的使用</title>
    <link href="http://editso.github.io/wiki/gdb-use/"/>
    <id>http://editso.github.io/wiki/gdb-use/</id>
    <published>2019-11-27T21:48:14.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gdb调试工具的使用"><a href="#gdb调试工具的使用" class="headerlink" title="gdb调试工具的使用"></a>gdb调试工具的使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单地说就是一个调试工具。它是一个受通用公共许可证即GPL保护的自由软件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用gdb调试工具时，在gcc打包为二进制文件时需要指定<code>-g</code>参数表示在该程序中添加调试语句<br>当编译好后，执行<code>gdb 需要被调试的程序</code>  </p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul><li><p><code>list</code> / <code>l</code><br>列出被调试程序的源代码，根据源码向指定位置设置断点<br>显示出源代码的下一页使用 <code>list / l</code></p></li><li><p><code>break</code> / <code>b</code><br>设置断点：<code>break / b 行号</code><br>设置条件断点：<code>b 行号 if 条件</code>当满足条件时才会执行，一般用在循环/递归语句</p></li><li><p><code>run</code> / <code>r</code><br>运行程序<br>不用设置断点直接执行，如果遇到程序出现错误时会显示出错的行数,可快速找到错误<br>该命令还可以在后面添加参数，每个参数以空格分开，它表示向<code>main</code>函数中传入参数</p></li><li><p><code>n</code> (next) / <code>S</code> (step)<br><code>n</code>/<code>S</code> 表示执行下一条指令<br>它们的区别在于执行函数的时候，当使用<code>n</code>来执行的时候会直接越过函数不会进入到函数内部执行而是直接执行到下一行,而<code>S</code>则反之<br>在调试时可以按需选择如何使用这两个命令<br>gbd调试时有一个小毛病就是在进入到函数内部时如果是库函数就会报<code>找不到那个文件</code>所以在使用时要注意执行遇到库函数时要使用<code>n</code>来执行</p></li><li><p><code>p</code><br>显示指定变量的值<code>p 变量名</code></p></li><li><p><code>continue</code><br>继续执行断点后续指令</p></li><li><p><code>quit</code><br>退出当前调试</p></li><li><p><code>finish</code><br>结束当前函数调用，回到调用点</p></li><li><p><code>set args</code><br><code>set args args1 args2 ..</code><br>在执行程序前设置命令行参数:</p></li><li><p><code>info b</code><br>查看<code>gdb</code>调试表中调试的内容</p></li><li><p><code>ptype</code><br>查看变量类型：<code>ptype 变量</code></p></li><li><p><code>bt</code>(backtrace)<br>列出当前程序正存活着的栈帧<br>它通常与<code>frame</code>配合使用</p></li><li><p><code>frame</code><br>根据栈帧编号，切换栈桢<br>它通常与<code>bt</code>配合使用</p></li><li><p><code>set follow-fork-mode [child | parent]</code>    </p><ul><li><code>child</code>: 跟踪子进程  </li><li><code>parent</code>: 跟踪父进程  </li></ul></li><li><p><code>display</code> &amp; <code>undisplay</code>   </p><ul><li><code>display</code>: 设置跟踪变量</li><li><code>undisplay</code>[编号]: 取消跟踪变量</li></ul></li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>栈帧: 随着函数调用而在<code>stack</code>上开辟的一片内存空间, 用于存放函数调用时产生的局部变量和临时值  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gdb调试工具的使用&quot;&gt;&lt;a href=&quot;#gdb调试工具的使用&quot; class=&quot;headerlink&quot; title=&quot;gdb调试工具的使用&quot;&gt;&lt;/a&gt;gdb调试工具的使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="软件相关" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    
    <category term="GDB" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/GDB/"/>
    
    
    <category term="C" scheme="http://editso.github.io/tags/C/"/>
    
    <category term="学习笔记" scheme="http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="GDB" scheme="http://editso.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器使用</title>
    <link href="http://editso.github.io/wiki/vim-use/"/>
    <id>http://editso.github.io/wiki/vim-use/</id>
    <published>2019-11-27T16:30:34.000Z</published>
    <updated>2023-06-29T10:21:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim-学习笔记"><a href="#vim-学习笔记" class="headerlink" title="vim 学习笔记"></a><code>vim</code> 学习笔记</h1><h2 id="vim三种模式"><a href="#vim三种模式" class="headerlink" title="vim三种模式"></a>vim三种模式</h2><ul><li>命令模式</li><li>末行模式</li><li>输入模式</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li>当刚刚启动vim时就为该模式<code>命令模式</code></li><li>该模式下所敲击的键盘都为命令</li><li>若想切换到<code>输入模式</code>可敲击字母按键 <code>i</code></li><li>若想切换到<code>末行默认</code>输入键盘中冒号 <code>:</code></li></ul><h3 id="命令模式相关命令"><a href="#命令模式相关命令" class="headerlink" title="命令模式相关命令"></a>命令模式相关命令</h3><p><code>i</code>: 在光标之前插入数据</p><p><code>I</code>: 光标所在行的行首插入数据</p><p><code>a</code>: 在光标之后插入数据</p><p><code>A</code>: 光标所在行的行尾插入数据</p><p><code>o</code>: 在光标所在行的下一行插入数据</p><p><code>O</code>: 光标所在行的上一行数据插入数据</p><p><code>s</code>: 向光标所在的那个字符插入数据并删除光标所指向的字符</p><p><code>S</code>: 向光标所在行插入数据并删除当前行所有数据</p><p><code>h</code> <code>j</code> <code>k</code> <code>l</code>: 分别代表 <code>左</code>/<code>下</code>/<code>上</code>/<code>右</code>移动</p><p><code>M</code>: 光标移动到中间行</p><p><code>L</code>: 光标移动到屏幕最后一行</p><p><code>G</code>: 跳转到指定行 <code>行号G</code>:<br>例如：移动到第二行<code>2G</code></p><p><code>gg</code>: 跳转到首行</p><p><code>GG</code>: 跳转到最后一行</p><p><code>gg=G</code>: 自动格式化文本</p><p><code>%</code>: 括号匹配</p><p><code>x</code>: 删除光标下的字符</p><p><code>dw</code>: 删除单词</p><p><code>D</code>: 删除光标到行尾的所有字符</p><p><code>0</code>: 光标移动到行首</p><p><code>$</code>: 光标移动到行尾</p><p><code>d0</code>: 删除光标到行首的所有字符</p><p><code>d$</code>: 删除光标到行尾的所有字符</p><p><code>r</code>: 替换光标下的字符</p><p><code>v</code>: 可视, 选中某区域使用 <code>h j k l</code>来移动选中区域</p><p><code>数字dd</code>: 删除n行</p><p><code>yy</code>: 复制一行</p><p><code>p</code>: 粘贴到光标下一行</p><p><code>P</code>: 粘贴到光标上一行</p><p>[数字]<code>yy</code>: 复制多行</p><p><code>u</code>  <code>ctr+r</code>: 撤销上一步<code>u</code>, 反撤销<code>ctr+r</code></p><p><code>/</code>: 查找<code>/查找的内容</code>  </p><ul><li>按<code>n</code>查找下一个  </li><li>按<code>N</code>查找上一个</li></ul><p><code>*</code>  <code>#</code>: 查找已知内容, 将光标移动到需要被查找的字符按  </p><ul><li><code>*</code>向后查找  </li><li><code>#</code>向前查找</li></ul><p><code>[d</code>: 查看宏定义（前提是该宏存在）</p><h2 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h2><p>按<code>esc</code>输入<code>:</code>进入末行模式</p><p><code>数字</code>: 跳转到指定的行<br>例如: 跳转到22行<code>:22</code></p><p><code>s /old/new</code>| <code>%s /old/new</code>| <code>%s /old/new/g</code>| <code>数字,数字s /old/new</code>  </p><ul><li>单行替换 将光标移动到需要被替换的行<code>:s /被替换的/替换后的</code>  </li><li>全文替换 <code>:%s /被替换的/替换后的</code> 只会替换每行的第一个被匹配的  </li><li>全文整行替换<code>:%s /被替换的/替换后的/g</code> 全文替换如一行多个匹配都会被替换  </li><li>区域替换<code>:开始行,结束行s /被替换的/替换后的</code> 替换指定区域中匹配的  </li></ul><p><code>sp</code> <code>vsp</code>: 分割窗口  </p><ul><li>垂直分割: <code>sp</code>  </li><li>水平分割: <code>vsp</code>  </li><li>切换页面: <code>ctr + ww</code>  </li><li>退出光标所在页面: <code>q</code>  </li><li>退出所有页面: <code>qall</code></li></ul><p><code>ctr+p</code>|<code>ctr+n</code>:  </p><ul><li>上一个命令<code>ctr+p</code></li><li>下一个命令<code>ctr+n</code></li></ul><p><code>w</code>: 保存不退出vim</p><p><code>qw</code>: 保存并退出</p><p><code>q!</code>: 不保存退出</p><p><code>!</code>: 不保存执行命令</p><ul><li><code>:!</code>[执行的命令]</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim-学习笔记&quot;&gt;&lt;a href=&quot;#vim-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;vim 学习笔记&quot;&gt;&lt;/a&gt;&lt;code&gt;vim&lt;/code&gt; 学习笔记&lt;/h1&gt;&lt;h2 id=&quot;vim三种模式&quot;&gt;&lt;a href=&quot;#vim三种模式&quot; </summary>
      
    
    
    
    <category term="软件相关" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Vim" scheme="http://editso.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/Vim/"/>
    
    
    <category term="学习笔记" scheme="http://editso.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Editor" scheme="http://editso.github.io/tags/Editor/"/>
    
  </entry>
  
</feed>
